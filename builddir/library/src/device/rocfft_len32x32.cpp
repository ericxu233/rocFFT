/*
 * Stockham kernels generated by:
 * 
 *     /home/ugrad/ugrad003/roctosycl/rocFFT/library/src/device/kernel-generator.py --pattern=all --precision=all --groups=150 --manual-small= --manual-large= generate /home/ugrad/ugrad003/roctosycl/rocFFT/builddir/library/src/device/generator/rocfft-kernel-generator
 * 
 * Generator is: /home/ugrad/ugrad003/roctosycl/rocFFT/library/src/device/kernel-generator.py
 * Kernel is: namespace(factors=[[8, 4], [8, 4]], flavour=('tall', 'tall'), length=[32, 32], scheme='CS_KERNEL_2D_SINGLE', threads_per_block=128, threads_per_transform=4)
 */

#include "kernel_launch.h"
#include "real2complex.h"
#include "rocfft_butterfly_template.h"
#include <hip/hip_runtime.h>

/* stockham.py:926 */
template <typename scalar_type, StrideBin sb>
__device__ void ip_forward_length32_SBRR_device(scalar_type* __restrict__ lds,
                                                const scalar_type* __restrict__ twiddles,
                                                size_t       stride_lds,
                                                unsigned int offset_lds,
                                                bool         write)
{
    size_t       thread;
    scalar_type  R[8];
    scalar_type  W;
    scalar_type  t;
    const size_t lstride = (sb == SB_UNIT) ? (1) : (stride_lds);

    thread = threadIdx.x % 4; /* stockham.py:873 */
    __syncthreads();

    // pass 0
    R[0] = lds[offset_lds + (thread * 1 + 0) * lstride]; /* stockham.py:889 */
    R[1] = lds[offset_lds + (thread * 1 + 4) * lstride]; /* stockham.py:889 */
    R[2] = lds[offset_lds + (thread * 1 + 8) * lstride]; /* stockham.py:889 */
    R[3] = lds[offset_lds + (thread * 1 + 12) * lstride]; /* stockham.py:889 */
    R[4] = lds[offset_lds + (thread * 1 + 16) * lstride]; /* stockham.py:889 */
    R[5] = lds[offset_lds + (thread * 1 + 20) * lstride]; /* stockham.py:889 */
    R[6] = lds[offset_lds + (thread * 1 + 24) * lstride]; /* stockham.py:889 */
    R[7] = lds[offset_lds + (thread * 1 + 28) * lstride]; /* stockham.py:889 */
    FwdRad8B1(&R[0], &R[1], &R[2], &R[3], &R[4], &R[5], &R[6], &R[7]); /* stockham.py:566 */

    __syncthreads();
    if(write)
    {
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 0) * lstride]
            = R[0]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 1) * lstride]
            = R[1]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 2) * lstride]
            = R[2]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 3) * lstride]
            = R[3]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 4) * lstride]
            = R[4]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 5) * lstride]
            = R[5]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 6) * lstride]
            = R[6]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 7) * lstride]
            = R[7]; /* stockham.py:913 */
    }

    // pass 1
    __syncthreads();

    R[0] = lds[offset_lds + (thread * 2 + 0) * lstride]; /* stockham.py:889 */
    R[1] = lds[offset_lds + (thread * 2 + 8) * lstride]; /* stockham.py:889 */
    R[2] = lds[offset_lds + (thread * 2 + 16) * lstride]; /* stockham.py:889 */
    R[3] = lds[offset_lds + (thread * 2 + 24) * lstride]; /* stockham.py:889 */
    R[4] = lds[offset_lds + (thread * 2 + 1) * lstride]; /* stockham.py:889 */
    R[5] = lds[offset_lds + (thread * 2 + 9) * lstride]; /* stockham.py:889 */
    R[6] = lds[offset_lds + (thread * 2 + 17) * lstride]; /* stockham.py:889 */
    R[7] = lds[offset_lds + (thread * 2 + 25) * lstride]; /* stockham.py:889 */
    W    = twiddles[7 + 3 * ((2 * thread + 0) % 8)]; /* stockham.py:898 */
    t.x  = W.x * R[1].x - W.y * R[1].y; /* stockham.py:899 */
    t.y  = W.y * R[1].x + W.x * R[1].y; /* stockham.py:900 */
    R[1] = t; /* stockham.py:901 */
    W    = twiddles[8 + 3 * ((2 * thread + 0) % 8)]; /* stockham.py:898 */
    t.x  = W.x * R[2].x - W.y * R[2].y; /* stockham.py:899 */
    t.y  = W.y * R[2].x + W.x * R[2].y; /* stockham.py:900 */
    R[2] = t; /* stockham.py:901 */
    W    = twiddles[9 + 3 * ((2 * thread + 0) % 8)]; /* stockham.py:898 */
    t.x  = W.x * R[3].x - W.y * R[3].y; /* stockham.py:899 */
    t.y  = W.y * R[3].x + W.x * R[3].y; /* stockham.py:900 */
    R[3] = t; /* stockham.py:901 */
    W    = twiddles[7 + 3 * ((2 * thread + 1) % 8)]; /* stockham.py:898 */
    t.x  = W.x * R[5].x - W.y * R[5].y; /* stockham.py:899 */
    t.y  = W.y * R[5].x + W.x * R[5].y; /* stockham.py:900 */
    R[5] = t; /* stockham.py:901 */
    W    = twiddles[8 + 3 * ((2 * thread + 1) % 8)]; /* stockham.py:898 */
    t.x  = W.x * R[6].x - W.y * R[6].y; /* stockham.py:899 */
    t.y  = W.y * R[6].x + W.x * R[6].y; /* stockham.py:900 */
    R[6] = t; /* stockham.py:901 */
    W    = twiddles[9 + 3 * ((2 * thread + 1) % 8)]; /* stockham.py:898 */
    t.x  = W.x * R[7].x - W.y * R[7].y; /* stockham.py:899 */
    t.y  = W.y * R[7].x + W.x * R[7].y; /* stockham.py:900 */
    R[7] = t; /* stockham.py:901 */

    FwdRad4B1(&R[0], &R[1], &R[2], &R[3]); /* stockham.py:566 */

    FwdRad4B1(&R[4], &R[5], &R[6], &R[7]); /* stockham.py:566 */

    __syncthreads();
    if(write)
    {
        lds[offset_lds + (((2 * thread + 0) / 8) * 32 + (2 * thread + 0) % 8 + 0) * lstride]
            = R[0]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 0) / 8) * 32 + (2 * thread + 0) % 8 + 8) * lstride]
            = R[1]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 0) / 8) * 32 + (2 * thread + 0) % 8 + 16) * lstride]
            = R[2]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 0) / 8) * 32 + (2 * thread + 0) % 8 + 24) * lstride]
            = R[3]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 1) / 8) * 32 + (2 * thread + 1) % 8 + 0) * lstride]
            = R[4]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 1) / 8) * 32 + (2 * thread + 1) % 8 + 8) * lstride]
            = R[5]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 1) / 8) * 32 + (2 * thread + 1) % 8 + 16) * lstride]
            = R[6]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 1) / 8) * 32 + (2 * thread + 1) % 8 + 24) * lstride]
            = R[7]; /* stockham.py:913 */
    }
}
/* stockham.py:1076 */
template <typename scalar_type, StrideBin sb, EmbeddedType ebtype, CallbackType cbtype>
__global__
    __launch_bounds__(128) void ip_forward_length32x32(const scalar_type* __restrict__ twiddles,
                                                       const size_t dim,
                                                       const size_t* __restrict__ lengths,
                                                       const size_t* __restrict__ stride,
                                                       const size_t       nbatch,
                                                       const unsigned int lds_padding,
                                                       void* __restrict__ load_cb_fn,
                                                       void* __restrict__ load_cb_data,
                                                       uint32_t load_cb_lds_bytes,
                                                       void* __restrict__ store_cb_fn,
                                                       void* __restrict__ store_cb_data,
                                                       scalar_type* __restrict__ buf)
{

    //
    // this kernel:
    //   uses 128 threads per 2d transform
    //   does 1 2d transforms per thread block
    // therefore it should be called with 128 threads per thread block
    //
    extern __shared__ unsigned char __align__(sizeof(scalar_type)) lds_uchar[];
    scalar_type* __restrict__ lds = reinterpret_cast<scalar_type*>(lds_uchar);
    size_t       thread;
    size_t       transform;
    size_t       offset = 0;
    unsigned int offset_lds;
    size_t       stride_lds;
    bool         write;
    size_t       stride0;
    size_t       batch0;
    size_t       batch1;
    size_t       remaining;
    size_t       plength = 1;
    int          d;
    size_t       index_along_d;
    auto         load_cb  = get_load_cb<scalar_type, cbtype>(load_cb_fn);
    auto         store_cb = get_store_cb<scalar_type, cbtype>(store_cb_fn);

    //
    // length: 32
    //

    // transform is: length 32 transform number
    // there are 32 * 1 = 32 of them per block
    transform = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:984 */
    remaining = transform; /* stockham.py:985 */
    for(d = 1; d < dim; ++d)
    {
        plength       = plength * lengths[d]; /* stockham.py:988 */
        index_along_d = remaining % lengths[d]; /* stockham.py:989 */
        remaining     = remaining / lengths[d]; /* stockham.py:990 */
        offset        = offset + index_along_d * stride[d]; /* stockham.py:991 */
    }
    batch0 = transform / plength; /* stockham.py:992 */
    offset = offset + batch0 * stride[dim]; /* stockham.py:993 */

    // load following length 32
    write      = batch0 < nbatch; /* stockham.py:999 */
    thread     = threadIdx.x % 4; /* stockham.py:1000 */
    stride0    = stride[0]; /* stockham.py:1001 */
    offset_lds = 32 * (transform % 32); /* stockham.py:1002 */
    if(write)
    {
        lds[offset_lds + thread + 0]
            = load_cb(buf, offset + (thread + 0) * stride0, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 4]
            = load_cb(buf, offset + (thread + 4) * stride0, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 8]
            = load_cb(buf, offset + (thread + 8) * stride0, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 12]
            = load_cb(buf, offset + (thread + 12) * stride0, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 16]
            = load_cb(buf, offset + (thread + 16) * stride0, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 20]
            = load_cb(buf, offset + (thread + 20) * stride0, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 24]
            = load_cb(buf, offset + (thread + 24) * stride0, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 28]
            = load_cb(buf, offset + (thread + 28) * stride0, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
    }
    stride_lds = 1; /* stockham.py:1011 */
    ip_forward_length32_SBRR_device<scalar_type, SB_UNIT>(
        lds, twiddles, stride_lds, offset_lds, write); /* generator.py:791 */

    //
    // length: 32
    //

    // transform is: length 32 transform number
    // there are 32 * 1 = 32 of them per block
    transform = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:1026 */
    plength   = lengths[0]; /* stockham.py:1027 */
    for(d = 2; d < dim; ++d)
    {
        plength = plength * lengths[d]; /* stockham.py:1030 */
    }
    batch1     = transform / plength; /* stockham.py:1031 */
    write      = batch1 < nbatch; /* stockham.py:1032 */
    thread     = threadIdx.x % 4; /* stockham.py:1033 */
    offset_lds = 1024 * ((transform % 32) / 32) + transform % 32; /* stockham.py:1034 */
    stride_lds = 32; /* stockham.py:1041 */
    ip_forward_length32_SBRR_device<scalar_type, SB_NONUNIT>(
        lds, twiddles, stride_lds, offset_lds, write); /* generator.py:791 */

    // store following length 32
    __syncthreads();
    transform  = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:1049 */
    write      = batch0 < nbatch; /* stockham.py:1054 */
    thread     = threadIdx.x % 4; /* stockham.py:1055 */
    offset_lds = 32 * (transform % 32); /* stockham.py:1056 */
    if(write)
    {
        store_cb(buf,
                 offset + (thread + 0) * stride0,
                 lds[offset_lds + thread + 0],
                 store_cb_data,
                 nullptr);
        store_cb(buf,
                 offset + (thread + 4) * stride0,
                 lds[offset_lds + thread + 4],
                 store_cb_data,
                 nullptr);
        store_cb(buf,
                 offset + (thread + 8) * stride0,
                 lds[offset_lds + thread + 8],
                 store_cb_data,
                 nullptr);
        store_cb(buf,
                 offset + (thread + 12) * stride0,
                 lds[offset_lds + thread + 12],
                 store_cb_data,
                 nullptr);
        store_cb(buf,
                 offset + (thread + 16) * stride0,
                 lds[offset_lds + thread + 16],
                 store_cb_data,
                 nullptr);
        store_cb(buf,
                 offset + (thread + 20) * stride0,
                 lds[offset_lds + thread + 20],
                 store_cb_data,
                 nullptr);
        store_cb(buf,
                 offset + (thread + 24) * stride0,
                 lds[offset_lds + thread + 24],
                 store_cb_data,
                 nullptr);
        store_cb(buf,
                 offset + (thread + 28) * stride0,
                 lds[offset_lds + thread + 28],
                 store_cb_data,
                 nullptr);
    }
}
/* stockham.py:1076 */
template <typename scalar_type, StrideBin sb, EmbeddedType ebtype, CallbackType cbtype>
__global__
    __launch_bounds__(128) void ip_forward_length32x32(const scalar_type* __restrict__ twiddles,
                                                       const size_t dim,
                                                       const size_t* __restrict__ lengths,
                                                       const size_t* __restrict__ stride,
                                                       const size_t       nbatch,
                                                       const unsigned int lds_padding,
                                                       void* __restrict__ load_cb_fn,
                                                       void* __restrict__ load_cb_data,
                                                       uint32_t load_cb_lds_bytes,
                                                       void* __restrict__ store_cb_fn,
                                                       void* __restrict__ store_cb_data,
                                                       real_type_t<scalar_type>* __restrict__ bufre,
                                                       real_type_t<scalar_type>* __restrict__ bufim)
{

    //
    // this kernel:
    //   uses 128 threads per 2d transform
    //   does 1 2d transforms per thread block
    // therefore it should be called with 128 threads per thread block
    //
    extern __shared__ unsigned char __align__(sizeof(scalar_type)) lds_uchar[];
    scalar_type* __restrict__ lds = reinterpret_cast<scalar_type*>(lds_uchar);
    size_t       thread;
    size_t       transform;
    size_t       offset = 0;
    unsigned int offset_lds;
    size_t       stride_lds;
    bool         write;
    size_t       stride0;
    size_t       batch0;
    size_t       batch1;
    size_t       remaining;
    size_t       plength = 1;
    int          d;
    size_t       index_along_d;
    auto         load_cb  = get_load_cb<scalar_type, cbtype>(load_cb_fn);
    auto         store_cb = get_store_cb<scalar_type, cbtype>(store_cb_fn);

    //
    // length: 32
    //

    // transform is: length 32 transform number
    // there are 32 * 1 = 32 of them per block
    transform = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:984 */
    remaining = transform; /* stockham.py:985 */
    for(d = 1; d < dim; ++d)
    {
        plength       = plength * lengths[d]; /* stockham.py:988 */
        index_along_d = remaining % lengths[d]; /* stockham.py:989 */
        remaining     = remaining / lengths[d]; /* stockham.py:990 */
        offset        = offset + index_along_d * stride[d]; /* stockham.py:991 */
    }
    batch0 = transform / plength; /* stockham.py:992 */
    offset = offset + batch0 * stride[dim]; /* stockham.py:993 */

    // load following length 32
    write      = batch0 < nbatch; /* stockham.py:999 */
    thread     = threadIdx.x % 4; /* stockham.py:1000 */
    stride0    = stride[0]; /* stockham.py:1001 */
    offset_lds = 32 * (transform % 32); /* stockham.py:1002 */
    if(write)
    {
        lds[offset_lds + thread + 0]
            = {bufre[offset + (thread + 0) * stride0],
               bufim[offset + (thread + 0) * stride0]}; /* generator.py:872 */
        lds[offset_lds + thread + 4]
            = {bufre[offset + (thread + 4) * stride0],
               bufim[offset + (thread + 4) * stride0]}; /* generator.py:872 */
        lds[offset_lds + thread + 8]
            = {bufre[offset + (thread + 8) * stride0],
               bufim[offset + (thread + 8) * stride0]}; /* generator.py:872 */
        lds[offset_lds + thread + 12]
            = {bufre[offset + (thread + 12) * stride0],
               bufim[offset + (thread + 12) * stride0]}; /* generator.py:872 */
        lds[offset_lds + thread + 16]
            = {bufre[offset + (thread + 16) * stride0],
               bufim[offset + (thread + 16) * stride0]}; /* generator.py:872 */
        lds[offset_lds + thread + 20]
            = {bufre[offset + (thread + 20) * stride0],
               bufim[offset + (thread + 20) * stride0]}; /* generator.py:872 */
        lds[offset_lds + thread + 24]
            = {bufre[offset + (thread + 24) * stride0],
               bufim[offset + (thread + 24) * stride0]}; /* generator.py:872 */
        lds[offset_lds + thread + 28]
            = {bufre[offset + (thread + 28) * stride0],
               bufim[offset + (thread + 28) * stride0]}; /* generator.py:872 */
    }
    stride_lds = 1; /* stockham.py:1011 */
    ip_forward_length32_SBRR_device<scalar_type, SB_UNIT>(
        lds, twiddles, stride_lds, offset_lds, write); /* generator.py:791 */

    //
    // length: 32
    //

    // transform is: length 32 transform number
    // there are 32 * 1 = 32 of them per block
    transform = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:1026 */
    plength   = lengths[0]; /* stockham.py:1027 */
    for(d = 2; d < dim; ++d)
    {
        plength = plength * lengths[d]; /* stockham.py:1030 */
    }
    batch1     = transform / plength; /* stockham.py:1031 */
    write      = batch1 < nbatch; /* stockham.py:1032 */
    thread     = threadIdx.x % 4; /* stockham.py:1033 */
    offset_lds = 1024 * ((transform % 32) / 32) + transform % 32; /* stockham.py:1034 */
    stride_lds = 32; /* stockham.py:1041 */
    ip_forward_length32_SBRR_device<scalar_type, SB_NONUNIT>(
        lds, twiddles, stride_lds, offset_lds, write); /* generator.py:791 */

    // store following length 32
    __syncthreads();
    transform  = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:1049 */
    write      = batch0 < nbatch; /* stockham.py:1054 */
    thread     = threadIdx.x % 4; /* stockham.py:1055 */
    offset_lds = 32 * (transform % 32); /* stockham.py:1056 */
    if(write)
    {
        bufre[offset + (thread + 0) * stride0]
            = lds[offset_lds + thread + 0].x; /* generator.py:906 */
        bufim[offset + (thread + 0) * stride0]
            = lds[offset_lds + thread + 0].y; /* generator.py:908 */
        bufre[offset + (thread + 4) * stride0]
            = lds[offset_lds + thread + 4].x; /* generator.py:906 */
        bufim[offset + (thread + 4) * stride0]
            = lds[offset_lds + thread + 4].y; /* generator.py:908 */
        bufre[offset + (thread + 8) * stride0]
            = lds[offset_lds + thread + 8].x; /* generator.py:906 */
        bufim[offset + (thread + 8) * stride0]
            = lds[offset_lds + thread + 8].y; /* generator.py:908 */
        bufre[offset + (thread + 12) * stride0]
            = lds[offset_lds + thread + 12].x; /* generator.py:906 */
        bufim[offset + (thread + 12) * stride0]
            = lds[offset_lds + thread + 12].y; /* generator.py:908 */
        bufre[offset + (thread + 16) * stride0]
            = lds[offset_lds + thread + 16].x; /* generator.py:906 */
        bufim[offset + (thread + 16) * stride0]
            = lds[offset_lds + thread + 16].y; /* generator.py:908 */
        bufre[offset + (thread + 20) * stride0]
            = lds[offset_lds + thread + 20].x; /* generator.py:906 */
        bufim[offset + (thread + 20) * stride0]
            = lds[offset_lds + thread + 20].y; /* generator.py:908 */
        bufre[offset + (thread + 24) * stride0]
            = lds[offset_lds + thread + 24].x; /* generator.py:906 */
        bufim[offset + (thread + 24) * stride0]
            = lds[offset_lds + thread + 24].y; /* generator.py:908 */
        bufre[offset + (thread + 28) * stride0]
            = lds[offset_lds + thread + 28].x; /* generator.py:906 */
        bufim[offset + (thread + 28) * stride0]
            = lds[offset_lds + thread + 28].y; /* generator.py:908 */
    }
}
/* stockham.py:926 */
template <typename scalar_type, StrideBin sb>
__device__ void op_forward_length32_SBRR_device(scalar_type* __restrict__ lds,
                                                const scalar_type* __restrict__ twiddles,
                                                size_t       stride_lds,
                                                unsigned int offset_lds,
                                                bool         write)
{
    size_t       thread;
    scalar_type  R[8];
    scalar_type  W;
    scalar_type  t;
    const size_t lstride = (sb == SB_UNIT) ? (1) : (stride_lds);

    thread = threadIdx.x % 4; /* stockham.py:873 */
    __syncthreads();

    // pass 0
    R[0] = lds[offset_lds + (thread * 1 + 0) * lstride]; /* stockham.py:889 */
    R[1] = lds[offset_lds + (thread * 1 + 4) * lstride]; /* stockham.py:889 */
    R[2] = lds[offset_lds + (thread * 1 + 8) * lstride]; /* stockham.py:889 */
    R[3] = lds[offset_lds + (thread * 1 + 12) * lstride]; /* stockham.py:889 */
    R[4] = lds[offset_lds + (thread * 1 + 16) * lstride]; /* stockham.py:889 */
    R[5] = lds[offset_lds + (thread * 1 + 20) * lstride]; /* stockham.py:889 */
    R[6] = lds[offset_lds + (thread * 1 + 24) * lstride]; /* stockham.py:889 */
    R[7] = lds[offset_lds + (thread * 1 + 28) * lstride]; /* stockham.py:889 */
    FwdRad8B1(&R[0], &R[1], &R[2], &R[3], &R[4], &R[5], &R[6], &R[7]); /* stockham.py:566 */

    __syncthreads();
    if(write)
    {
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 0) * lstride]
            = R[0]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 1) * lstride]
            = R[1]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 2) * lstride]
            = R[2]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 3) * lstride]
            = R[3]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 4) * lstride]
            = R[4]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 5) * lstride]
            = R[5]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 6) * lstride]
            = R[6]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 7) * lstride]
            = R[7]; /* stockham.py:913 */
    }

    // pass 1
    __syncthreads();

    R[0] = lds[offset_lds + (thread * 2 + 0) * lstride]; /* stockham.py:889 */
    R[1] = lds[offset_lds + (thread * 2 + 8) * lstride]; /* stockham.py:889 */
    R[2] = lds[offset_lds + (thread * 2 + 16) * lstride]; /* stockham.py:889 */
    R[3] = lds[offset_lds + (thread * 2 + 24) * lstride]; /* stockham.py:889 */
    R[4] = lds[offset_lds + (thread * 2 + 1) * lstride]; /* stockham.py:889 */
    R[5] = lds[offset_lds + (thread * 2 + 9) * lstride]; /* stockham.py:889 */
    R[6] = lds[offset_lds + (thread * 2 + 17) * lstride]; /* stockham.py:889 */
    R[7] = lds[offset_lds + (thread * 2 + 25) * lstride]; /* stockham.py:889 */
    W    = twiddles[7 + 3 * ((2 * thread + 0) % 8)]; /* stockham.py:898 */
    t.x  = W.x * R[1].x - W.y * R[1].y; /* stockham.py:899 */
    t.y  = W.y * R[1].x + W.x * R[1].y; /* stockham.py:900 */
    R[1] = t; /* stockham.py:901 */
    W    = twiddles[8 + 3 * ((2 * thread + 0) % 8)]; /* stockham.py:898 */
    t.x  = W.x * R[2].x - W.y * R[2].y; /* stockham.py:899 */
    t.y  = W.y * R[2].x + W.x * R[2].y; /* stockham.py:900 */
    R[2] = t; /* stockham.py:901 */
    W    = twiddles[9 + 3 * ((2 * thread + 0) % 8)]; /* stockham.py:898 */
    t.x  = W.x * R[3].x - W.y * R[3].y; /* stockham.py:899 */
    t.y  = W.y * R[3].x + W.x * R[3].y; /* stockham.py:900 */
    R[3] = t; /* stockham.py:901 */
    W    = twiddles[7 + 3 * ((2 * thread + 1) % 8)]; /* stockham.py:898 */
    t.x  = W.x * R[5].x - W.y * R[5].y; /* stockham.py:899 */
    t.y  = W.y * R[5].x + W.x * R[5].y; /* stockham.py:900 */
    R[5] = t; /* stockham.py:901 */
    W    = twiddles[8 + 3 * ((2 * thread + 1) % 8)]; /* stockham.py:898 */
    t.x  = W.x * R[6].x - W.y * R[6].y; /* stockham.py:899 */
    t.y  = W.y * R[6].x + W.x * R[6].y; /* stockham.py:900 */
    R[6] = t; /* stockham.py:901 */
    W    = twiddles[9 + 3 * ((2 * thread + 1) % 8)]; /* stockham.py:898 */
    t.x  = W.x * R[7].x - W.y * R[7].y; /* stockham.py:899 */
    t.y  = W.y * R[7].x + W.x * R[7].y; /* stockham.py:900 */
    R[7] = t; /* stockham.py:901 */

    FwdRad4B1(&R[0], &R[1], &R[2], &R[3]); /* stockham.py:566 */

    FwdRad4B1(&R[4], &R[5], &R[6], &R[7]); /* stockham.py:566 */

    __syncthreads();
    if(write)
    {
        lds[offset_lds + (((2 * thread + 0) / 8) * 32 + (2 * thread + 0) % 8 + 0) * lstride]
            = R[0]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 0) / 8) * 32 + (2 * thread + 0) % 8 + 8) * lstride]
            = R[1]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 0) / 8) * 32 + (2 * thread + 0) % 8 + 16) * lstride]
            = R[2]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 0) / 8) * 32 + (2 * thread + 0) % 8 + 24) * lstride]
            = R[3]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 1) / 8) * 32 + (2 * thread + 1) % 8 + 0) * lstride]
            = R[4]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 1) / 8) * 32 + (2 * thread + 1) % 8 + 8) * lstride]
            = R[5]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 1) / 8) * 32 + (2 * thread + 1) % 8 + 16) * lstride]
            = R[6]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 1) / 8) * 32 + (2 * thread + 1) % 8 + 24) * lstride]
            = R[7]; /* stockham.py:913 */
    }
}
/* stockham.py:1076 */
template <typename scalar_type, StrideBin sb, EmbeddedType ebtype, CallbackType cbtype>
__global__
    __launch_bounds__(128) void op_forward_length32x32(const scalar_type* __restrict__ twiddles,
                                                       const size_t dim,
                                                       const size_t* __restrict__ lengths,
                                                       const size_t* __restrict__ stride_in,
                                                       const size_t* __restrict__ stride_out,
                                                       const size_t       nbatch,
                                                       const unsigned int lds_padding,
                                                       void* __restrict__ load_cb_fn,
                                                       void* __restrict__ load_cb_data,
                                                       uint32_t load_cb_lds_bytes,
                                                       void* __restrict__ store_cb_fn,
                                                       void* __restrict__ store_cb_data,
                                                       scalar_type* __restrict__ buf_in,
                                                       scalar_type* __restrict__ buf_out)
{

    //
    // this kernel:
    //   uses 128 threads per 2d transform
    //   does 1 2d transforms per thread block
    // therefore it should be called with 128 threads per thread block
    //
    extern __shared__ unsigned char __align__(sizeof(scalar_type)) lds_uchar[];
    scalar_type* __restrict__ lds = reinterpret_cast<scalar_type*>(lds_uchar);
    size_t       thread;
    size_t       transform;
    size_t       offset_in  = 0;
    size_t       offset_out = 0;
    unsigned int offset_lds;
    size_t       stride_lds;
    bool         write;
    size_t       stride0_in;
    size_t       stride0_out;
    size_t       batch0;
    size_t       batch1;
    size_t       remaining;
    size_t       plength = 1;
    int          d;
    size_t       index_along_d;
    auto         load_cb  = get_load_cb<scalar_type, cbtype>(load_cb_fn);
    auto         store_cb = get_store_cb<scalar_type, cbtype>(store_cb_fn);

    //
    // length: 32
    //

    // transform is: length 32 transform number
    // there are 32 * 1 = 32 of them per block
    transform = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:984 */
    remaining = transform; /* stockham.py:985 */
    for(d = 1; d < dim; ++d)
    {
        plength       = plength * lengths[d]; /* stockham.py:988 */
        index_along_d = remaining % lengths[d]; /* stockham.py:989 */
        remaining     = remaining / lengths[d]; /* stockham.py:990 */
        offset_in     = offset_in + index_along_d * stride_in[d]; /* generator.py:992 */
        offset_out    = offset_out + index_along_d * stride_out[d]; /* generator.py:993 */
    }
    batch0     = transform / plength; /* stockham.py:992 */
    offset_in  = offset_in + batch0 * stride_in[dim]; /* generator.py:992 */
    offset_out = offset_out + batch0 * stride_out[dim]; /* generator.py:993 */

    // load following length 32
    write       = batch0 < nbatch; /* stockham.py:999 */
    thread      = threadIdx.x % 4; /* stockham.py:1000 */
    stride0_in  = stride_in[0]; /* generator.py:992 */
    stride0_out = stride_out[0]; /* generator.py:993 */
    offset_lds  = 32 * (transform % 32); /* stockham.py:1002 */
    if(write)
    {
        lds[offset_lds + thread + 0]
            = load_cb(buf_in, offset_in + (thread + 0) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 4]
            = load_cb(buf_in, offset_in + (thread + 4) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 8]
            = load_cb(buf_in, offset_in + (thread + 8) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 12]
            = load_cb(buf_in, offset_in + (thread + 12) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 16]
            = load_cb(buf_in, offset_in + (thread + 16) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 20]
            = load_cb(buf_in, offset_in + (thread + 20) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 24]
            = load_cb(buf_in, offset_in + (thread + 24) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 28]
            = load_cb(buf_in, offset_in + (thread + 28) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
    }
    stride_lds = 1; /* stockham.py:1011 */
    op_forward_length32_SBRR_device<scalar_type, SB_UNIT>(
        lds, twiddles, stride_lds, offset_lds, write); /* generator.py:791 */

    //
    // length: 32
    //

    // transform is: length 32 transform number
    // there are 32 * 1 = 32 of them per block
    transform = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:1026 */
    plength   = lengths[0]; /* stockham.py:1027 */
    for(d = 2; d < dim; ++d)
    {
        plength = plength * lengths[d]; /* stockham.py:1030 */
    }
    batch1     = transform / plength; /* stockham.py:1031 */
    write      = batch1 < nbatch; /* stockham.py:1032 */
    thread     = threadIdx.x % 4; /* stockham.py:1033 */
    offset_lds = 1024 * ((transform % 32) / 32) + transform % 32; /* stockham.py:1034 */
    stride_lds = 32; /* stockham.py:1041 */
    op_forward_length32_SBRR_device<scalar_type, SB_NONUNIT>(
        lds, twiddles, stride_lds, offset_lds, write); /* generator.py:791 */

    // store following length 32
    __syncthreads();
    transform  = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:1049 */
    write      = batch0 < nbatch; /* stockham.py:1054 */
    thread     = threadIdx.x % 4; /* stockham.py:1055 */
    offset_lds = 32 * (transform % 32); /* stockham.py:1056 */
    if(write)
    {
        store_cb(buf_out,
                 offset_out + (thread + 0) * stride0_out,
                 lds[offset_lds + thread + 0],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 4) * stride0_out,
                 lds[offset_lds + thread + 4],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 8) * stride0_out,
                 lds[offset_lds + thread + 8],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 12) * stride0_out,
                 lds[offset_lds + thread + 12],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 16) * stride0_out,
                 lds[offset_lds + thread + 16],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 20) * stride0_out,
                 lds[offset_lds + thread + 20],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 24) * stride0_out,
                 lds[offset_lds + thread + 24],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 28) * stride0_out,
                 lds[offset_lds + thread + 28],
                 store_cb_data,
                 nullptr);
    }
}
/* stockham.py:1076 */
template <typename scalar_type, StrideBin sb, EmbeddedType ebtype, CallbackType cbtype>
__global__ __launch_bounds__(128) void op_forward_length32x32(
    const scalar_type* __restrict__ twiddles,
    const size_t dim,
    const size_t* __restrict__ lengths,
    const size_t* __restrict__ stride_in,
    const size_t* __restrict__ stride_out,
    const size_t       nbatch,
    const unsigned int lds_padding,
    void* __restrict__ load_cb_fn,
    void* __restrict__ load_cb_data,
    uint32_t load_cb_lds_bytes,
    void* __restrict__ store_cb_fn,
    void* __restrict__ store_cb_data,
    scalar_type* __restrict__ buf_in,
    real_type_t<scalar_type>* __restrict__ buf_outre,
    real_type_t<scalar_type>* __restrict__ buf_outim)
{

    //
    // this kernel:
    //   uses 128 threads per 2d transform
    //   does 1 2d transforms per thread block
    // therefore it should be called with 128 threads per thread block
    //
    extern __shared__ unsigned char __align__(sizeof(scalar_type)) lds_uchar[];
    scalar_type* __restrict__ lds = reinterpret_cast<scalar_type*>(lds_uchar);
    size_t       thread;
    size_t       transform;
    size_t       offset_in  = 0;
    size_t       offset_out = 0;
    unsigned int offset_lds;
    size_t       stride_lds;
    bool         write;
    size_t       stride0_in;
    size_t       stride0_out;
    size_t       batch0;
    size_t       batch1;
    size_t       remaining;
    size_t       plength = 1;
    int          d;
    size_t       index_along_d;
    auto         load_cb  = get_load_cb<scalar_type, cbtype>(load_cb_fn);
    auto         store_cb = get_store_cb<scalar_type, cbtype>(store_cb_fn);

    //
    // length: 32
    //

    // transform is: length 32 transform number
    // there are 32 * 1 = 32 of them per block
    transform = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:984 */
    remaining = transform; /* stockham.py:985 */
    for(d = 1; d < dim; ++d)
    {
        plength       = plength * lengths[d]; /* stockham.py:988 */
        index_along_d = remaining % lengths[d]; /* stockham.py:989 */
        remaining     = remaining / lengths[d]; /* stockham.py:990 */
        offset_in     = offset_in + index_along_d * stride_in[d]; /* generator.py:992 */
        offset_out    = offset_out + index_along_d * stride_out[d]; /* generator.py:993 */
    }
    batch0     = transform / plength; /* stockham.py:992 */
    offset_in  = offset_in + batch0 * stride_in[dim]; /* generator.py:992 */
    offset_out = offset_out + batch0 * stride_out[dim]; /* generator.py:993 */

    // load following length 32
    write       = batch0 < nbatch; /* stockham.py:999 */
    thread      = threadIdx.x % 4; /* stockham.py:1000 */
    stride0_in  = stride_in[0]; /* generator.py:992 */
    stride0_out = stride_out[0]; /* generator.py:993 */
    offset_lds  = 32 * (transform % 32); /* stockham.py:1002 */
    if(write)
    {
        lds[offset_lds + thread + 0]
            = load_cb(buf_in, offset_in + (thread + 0) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 4]
            = load_cb(buf_in, offset_in + (thread + 4) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 8]
            = load_cb(buf_in, offset_in + (thread + 8) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 12]
            = load_cb(buf_in, offset_in + (thread + 12) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 16]
            = load_cb(buf_in, offset_in + (thread + 16) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 20]
            = load_cb(buf_in, offset_in + (thread + 20) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 24]
            = load_cb(buf_in, offset_in + (thread + 24) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 28]
            = load_cb(buf_in, offset_in + (thread + 28) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
    }
    stride_lds = 1; /* stockham.py:1011 */
    op_forward_length32_SBRR_device<scalar_type, SB_UNIT>(
        lds, twiddles, stride_lds, offset_lds, write); /* generator.py:791 */

    //
    // length: 32
    //

    // transform is: length 32 transform number
    // there are 32 * 1 = 32 of them per block
    transform = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:1026 */
    plength   = lengths[0]; /* stockham.py:1027 */
    for(d = 2; d < dim; ++d)
    {
        plength = plength * lengths[d]; /* stockham.py:1030 */
    }
    batch1     = transform / plength; /* stockham.py:1031 */
    write      = batch1 < nbatch; /* stockham.py:1032 */
    thread     = threadIdx.x % 4; /* stockham.py:1033 */
    offset_lds = 1024 * ((transform % 32) / 32) + transform % 32; /* stockham.py:1034 */
    stride_lds = 32; /* stockham.py:1041 */
    op_forward_length32_SBRR_device<scalar_type, SB_NONUNIT>(
        lds, twiddles, stride_lds, offset_lds, write); /* generator.py:791 */

    // store following length 32
    __syncthreads();
    transform  = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:1049 */
    write      = batch0 < nbatch; /* stockham.py:1054 */
    thread     = threadIdx.x % 4; /* stockham.py:1055 */
    offset_lds = 32 * (transform % 32); /* stockham.py:1056 */
    if(write)
    {
        buf_outre[offset_out + (thread + 0) * stride0_out]
            = lds[offset_lds + thread + 0].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 0) * stride0_out]
            = lds[offset_lds + thread + 0].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 4) * stride0_out]
            = lds[offset_lds + thread + 4].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 4) * stride0_out]
            = lds[offset_lds + thread + 4].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 8) * stride0_out]
            = lds[offset_lds + thread + 8].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 8) * stride0_out]
            = lds[offset_lds + thread + 8].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 12) * stride0_out]
            = lds[offset_lds + thread + 12].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 12) * stride0_out]
            = lds[offset_lds + thread + 12].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 16) * stride0_out]
            = lds[offset_lds + thread + 16].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 16) * stride0_out]
            = lds[offset_lds + thread + 16].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 20) * stride0_out]
            = lds[offset_lds + thread + 20].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 20) * stride0_out]
            = lds[offset_lds + thread + 20].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 24) * stride0_out]
            = lds[offset_lds + thread + 24].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 24) * stride0_out]
            = lds[offset_lds + thread + 24].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 28) * stride0_out]
            = lds[offset_lds + thread + 28].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 28) * stride0_out]
            = lds[offset_lds + thread + 28].y; /* generator.py:908 */
    }
}
/* stockham.py:1076 */
template <typename scalar_type, StrideBin sb, EmbeddedType ebtype, CallbackType cbtype>
__global__ __launch_bounds__(128) void op_forward_length32x32(
    const scalar_type* __restrict__ twiddles,
    const size_t dim,
    const size_t* __restrict__ lengths,
    const size_t* __restrict__ stride_in,
    const size_t* __restrict__ stride_out,
    const size_t       nbatch,
    const unsigned int lds_padding,
    void* __restrict__ load_cb_fn,
    void* __restrict__ load_cb_data,
    uint32_t load_cb_lds_bytes,
    void* __restrict__ store_cb_fn,
    void* __restrict__ store_cb_data,
    real_type_t<scalar_type>* __restrict__ buf_inre,
    real_type_t<scalar_type>* __restrict__ buf_inim,
    scalar_type* __restrict__ buf_out)
{

    //
    // this kernel:
    //   uses 128 threads per 2d transform
    //   does 1 2d transforms per thread block
    // therefore it should be called with 128 threads per thread block
    //
    extern __shared__ unsigned char __align__(sizeof(scalar_type)) lds_uchar[];
    scalar_type* __restrict__ lds = reinterpret_cast<scalar_type*>(lds_uchar);
    size_t       thread;
    size_t       transform;
    size_t       offset_in  = 0;
    size_t       offset_out = 0;
    unsigned int offset_lds;
    size_t       stride_lds;
    bool         write;
    size_t       stride0_in;
    size_t       stride0_out;
    size_t       batch0;
    size_t       batch1;
    size_t       remaining;
    size_t       plength = 1;
    int          d;
    size_t       index_along_d;
    auto         load_cb  = get_load_cb<scalar_type, cbtype>(load_cb_fn);
    auto         store_cb = get_store_cb<scalar_type, cbtype>(store_cb_fn);

    //
    // length: 32
    //

    // transform is: length 32 transform number
    // there are 32 * 1 = 32 of them per block
    transform = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:984 */
    remaining = transform; /* stockham.py:985 */
    for(d = 1; d < dim; ++d)
    {
        plength       = plength * lengths[d]; /* stockham.py:988 */
        index_along_d = remaining % lengths[d]; /* stockham.py:989 */
        remaining     = remaining / lengths[d]; /* stockham.py:990 */
        offset_in     = offset_in + index_along_d * stride_in[d]; /* generator.py:992 */
        offset_out    = offset_out + index_along_d * stride_out[d]; /* generator.py:993 */
    }
    batch0     = transform / plength; /* stockham.py:992 */
    offset_in  = offset_in + batch0 * stride_in[dim]; /* generator.py:992 */
    offset_out = offset_out + batch0 * stride_out[dim]; /* generator.py:993 */

    // load following length 32
    write       = batch0 < nbatch; /* stockham.py:999 */
    thread      = threadIdx.x % 4; /* stockham.py:1000 */
    stride0_in  = stride_in[0]; /* generator.py:992 */
    stride0_out = stride_out[0]; /* generator.py:993 */
    offset_lds  = 32 * (transform % 32); /* stockham.py:1002 */
    if(write)
    {
        lds[offset_lds + thread + 0]
            = {buf_inre[offset_in + (thread + 0) * stride0_in],
               buf_inim[offset_in + (thread + 0) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 4]
            = {buf_inre[offset_in + (thread + 4) * stride0_in],
               buf_inim[offset_in + (thread + 4) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 8]
            = {buf_inre[offset_in + (thread + 8) * stride0_in],
               buf_inim[offset_in + (thread + 8) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 12]
            = {buf_inre[offset_in + (thread + 12) * stride0_in],
               buf_inim[offset_in + (thread + 12) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 16]
            = {buf_inre[offset_in + (thread + 16) * stride0_in],
               buf_inim[offset_in + (thread + 16) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 20]
            = {buf_inre[offset_in + (thread + 20) * stride0_in],
               buf_inim[offset_in + (thread + 20) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 24]
            = {buf_inre[offset_in + (thread + 24) * stride0_in],
               buf_inim[offset_in + (thread + 24) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 28]
            = {buf_inre[offset_in + (thread + 28) * stride0_in],
               buf_inim[offset_in + (thread + 28) * stride0_in]}; /* generator.py:872 */
    }
    stride_lds = 1; /* stockham.py:1011 */
    op_forward_length32_SBRR_device<scalar_type, SB_UNIT>(
        lds, twiddles, stride_lds, offset_lds, write); /* generator.py:791 */

    //
    // length: 32
    //

    // transform is: length 32 transform number
    // there are 32 * 1 = 32 of them per block
    transform = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:1026 */
    plength   = lengths[0]; /* stockham.py:1027 */
    for(d = 2; d < dim; ++d)
    {
        plength = plength * lengths[d]; /* stockham.py:1030 */
    }
    batch1     = transform / plength; /* stockham.py:1031 */
    write      = batch1 < nbatch; /* stockham.py:1032 */
    thread     = threadIdx.x % 4; /* stockham.py:1033 */
    offset_lds = 1024 * ((transform % 32) / 32) + transform % 32; /* stockham.py:1034 */
    stride_lds = 32; /* stockham.py:1041 */
    op_forward_length32_SBRR_device<scalar_type, SB_NONUNIT>(
        lds, twiddles, stride_lds, offset_lds, write); /* generator.py:791 */

    // store following length 32
    __syncthreads();
    transform  = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:1049 */
    write      = batch0 < nbatch; /* stockham.py:1054 */
    thread     = threadIdx.x % 4; /* stockham.py:1055 */
    offset_lds = 32 * (transform % 32); /* stockham.py:1056 */
    if(write)
    {
        store_cb(buf_out,
                 offset_out + (thread + 0) * stride0_out,
                 lds[offset_lds + thread + 0],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 4) * stride0_out,
                 lds[offset_lds + thread + 4],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 8) * stride0_out,
                 lds[offset_lds + thread + 8],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 12) * stride0_out,
                 lds[offset_lds + thread + 12],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 16) * stride0_out,
                 lds[offset_lds + thread + 16],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 20) * stride0_out,
                 lds[offset_lds + thread + 20],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 24) * stride0_out,
                 lds[offset_lds + thread + 24],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 28) * stride0_out,
                 lds[offset_lds + thread + 28],
                 store_cb_data,
                 nullptr);
    }
}
/* stockham.py:1076 */
template <typename scalar_type, StrideBin sb, EmbeddedType ebtype, CallbackType cbtype>
__global__ __launch_bounds__(128) void op_forward_length32x32(
    const scalar_type* __restrict__ twiddles,
    const size_t dim,
    const size_t* __restrict__ lengths,
    const size_t* __restrict__ stride_in,
    const size_t* __restrict__ stride_out,
    const size_t       nbatch,
    const unsigned int lds_padding,
    void* __restrict__ load_cb_fn,
    void* __restrict__ load_cb_data,
    uint32_t load_cb_lds_bytes,
    void* __restrict__ store_cb_fn,
    void* __restrict__ store_cb_data,
    real_type_t<scalar_type>* __restrict__ buf_inre,
    real_type_t<scalar_type>* __restrict__ buf_inim,
    real_type_t<scalar_type>* __restrict__ buf_outre,
    real_type_t<scalar_type>* __restrict__ buf_outim)
{

    //
    // this kernel:
    //   uses 128 threads per 2d transform
    //   does 1 2d transforms per thread block
    // therefore it should be called with 128 threads per thread block
    //
    extern __shared__ unsigned char __align__(sizeof(scalar_type)) lds_uchar[];
    scalar_type* __restrict__ lds = reinterpret_cast<scalar_type*>(lds_uchar);
    size_t       thread;
    size_t       transform;
    size_t       offset_in  = 0;
    size_t       offset_out = 0;
    unsigned int offset_lds;
    size_t       stride_lds;
    bool         write;
    size_t       stride0_in;
    size_t       stride0_out;
    size_t       batch0;
    size_t       batch1;
    size_t       remaining;
    size_t       plength = 1;
    int          d;
    size_t       index_along_d;
    auto         load_cb  = get_load_cb<scalar_type, cbtype>(load_cb_fn);
    auto         store_cb = get_store_cb<scalar_type, cbtype>(store_cb_fn);

    //
    // length: 32
    //

    // transform is: length 32 transform number
    // there are 32 * 1 = 32 of them per block
    transform = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:984 */
    remaining = transform; /* stockham.py:985 */
    for(d = 1; d < dim; ++d)
    {
        plength       = plength * lengths[d]; /* stockham.py:988 */
        index_along_d = remaining % lengths[d]; /* stockham.py:989 */
        remaining     = remaining / lengths[d]; /* stockham.py:990 */
        offset_in     = offset_in + index_along_d * stride_in[d]; /* generator.py:992 */
        offset_out    = offset_out + index_along_d * stride_out[d]; /* generator.py:993 */
    }
    batch0     = transform / plength; /* stockham.py:992 */
    offset_in  = offset_in + batch0 * stride_in[dim]; /* generator.py:992 */
    offset_out = offset_out + batch0 * stride_out[dim]; /* generator.py:993 */

    // load following length 32
    write       = batch0 < nbatch; /* stockham.py:999 */
    thread      = threadIdx.x % 4; /* stockham.py:1000 */
    stride0_in  = stride_in[0]; /* generator.py:992 */
    stride0_out = stride_out[0]; /* generator.py:993 */
    offset_lds  = 32 * (transform % 32); /* stockham.py:1002 */
    if(write)
    {
        lds[offset_lds + thread + 0]
            = {buf_inre[offset_in + (thread + 0) * stride0_in],
               buf_inim[offset_in + (thread + 0) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 4]
            = {buf_inre[offset_in + (thread + 4) * stride0_in],
               buf_inim[offset_in + (thread + 4) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 8]
            = {buf_inre[offset_in + (thread + 8) * stride0_in],
               buf_inim[offset_in + (thread + 8) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 12]
            = {buf_inre[offset_in + (thread + 12) * stride0_in],
               buf_inim[offset_in + (thread + 12) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 16]
            = {buf_inre[offset_in + (thread + 16) * stride0_in],
               buf_inim[offset_in + (thread + 16) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 20]
            = {buf_inre[offset_in + (thread + 20) * stride0_in],
               buf_inim[offset_in + (thread + 20) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 24]
            = {buf_inre[offset_in + (thread + 24) * stride0_in],
               buf_inim[offset_in + (thread + 24) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 28]
            = {buf_inre[offset_in + (thread + 28) * stride0_in],
               buf_inim[offset_in + (thread + 28) * stride0_in]}; /* generator.py:872 */
    }
    stride_lds = 1; /* stockham.py:1011 */
    op_forward_length32_SBRR_device<scalar_type, SB_UNIT>(
        lds, twiddles, stride_lds, offset_lds, write); /* generator.py:791 */

    //
    // length: 32
    //

    // transform is: length 32 transform number
    // there are 32 * 1 = 32 of them per block
    transform = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:1026 */
    plength   = lengths[0]; /* stockham.py:1027 */
    for(d = 2; d < dim; ++d)
    {
        plength = plength * lengths[d]; /* stockham.py:1030 */
    }
    batch1     = transform / plength; /* stockham.py:1031 */
    write      = batch1 < nbatch; /* stockham.py:1032 */
    thread     = threadIdx.x % 4; /* stockham.py:1033 */
    offset_lds = 1024 * ((transform % 32) / 32) + transform % 32; /* stockham.py:1034 */
    stride_lds = 32; /* stockham.py:1041 */
    op_forward_length32_SBRR_device<scalar_type, SB_NONUNIT>(
        lds, twiddles, stride_lds, offset_lds, write); /* generator.py:791 */

    // store following length 32
    __syncthreads();
    transform  = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:1049 */
    write      = batch0 < nbatch; /* stockham.py:1054 */
    thread     = threadIdx.x % 4; /* stockham.py:1055 */
    offset_lds = 32 * (transform % 32); /* stockham.py:1056 */
    if(write)
    {
        buf_outre[offset_out + (thread + 0) * stride0_out]
            = lds[offset_lds + thread + 0].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 0) * stride0_out]
            = lds[offset_lds + thread + 0].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 4) * stride0_out]
            = lds[offset_lds + thread + 4].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 4) * stride0_out]
            = lds[offset_lds + thread + 4].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 8) * stride0_out]
            = lds[offset_lds + thread + 8].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 8) * stride0_out]
            = lds[offset_lds + thread + 8].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 12) * stride0_out]
            = lds[offset_lds + thread + 12].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 12) * stride0_out]
            = lds[offset_lds + thread + 12].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 16) * stride0_out]
            = lds[offset_lds + thread + 16].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 16) * stride0_out]
            = lds[offset_lds + thread + 16].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 20) * stride0_out]
            = lds[offset_lds + thread + 20].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 20) * stride0_out]
            = lds[offset_lds + thread + 20].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 24) * stride0_out]
            = lds[offset_lds + thread + 24].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 24) * stride0_out]
            = lds[offset_lds + thread + 24].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 28) * stride0_out]
            = lds[offset_lds + thread + 28].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 28) * stride0_out]
            = lds[offset_lds + thread + 28].y; /* generator.py:908 */
    }
}
/* stockham.py:926 */
template <typename scalar_type, StrideBin sb>
__device__ void ip_inverse_length32_SBRR_device(scalar_type* __restrict__ lds,
                                                const scalar_type* __restrict__ twiddles,
                                                size_t       stride_lds,
                                                unsigned int offset_lds,
                                                bool         write)
{
    size_t       thread;
    scalar_type  R[8];
    scalar_type  W;
    scalar_type  t;
    const size_t lstride = (sb == SB_UNIT) ? (1) : (stride_lds);

    thread = threadIdx.x % 4; /* stockham.py:873 */
    __syncthreads();

    // pass 0
    R[0] = lds[offset_lds + (thread * 1 + 0) * lstride]; /* stockham.py:889 */
    R[1] = lds[offset_lds + (thread * 1 + 4) * lstride]; /* stockham.py:889 */
    R[2] = lds[offset_lds + (thread * 1 + 8) * lstride]; /* stockham.py:889 */
    R[3] = lds[offset_lds + (thread * 1 + 12) * lstride]; /* stockham.py:889 */
    R[4] = lds[offset_lds + (thread * 1 + 16) * lstride]; /* stockham.py:889 */
    R[5] = lds[offset_lds + (thread * 1 + 20) * lstride]; /* stockham.py:889 */
    R[6] = lds[offset_lds + (thread * 1 + 24) * lstride]; /* stockham.py:889 */
    R[7] = lds[offset_lds + (thread * 1 + 28) * lstride]; /* stockham.py:889 */
    InvRad8B1(&R[0], &R[1], &R[2], &R[3], &R[4], &R[5], &R[6], &R[7]); /* stockham.py:566 */

    __syncthreads();
    if(write)
    {
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 0) * lstride]
            = R[0]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 1) * lstride]
            = R[1]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 2) * lstride]
            = R[2]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 3) * lstride]
            = R[3]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 4) * lstride]
            = R[4]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 5) * lstride]
            = R[5]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 6) * lstride]
            = R[6]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 7) * lstride]
            = R[7]; /* stockham.py:913 */
    }

    // pass 1
    __syncthreads();

    R[0] = lds[offset_lds + (thread * 2 + 0) * lstride]; /* stockham.py:889 */
    R[1] = lds[offset_lds + (thread * 2 + 8) * lstride]; /* stockham.py:889 */
    R[2] = lds[offset_lds + (thread * 2 + 16) * lstride]; /* stockham.py:889 */
    R[3] = lds[offset_lds + (thread * 2 + 24) * lstride]; /* stockham.py:889 */
    R[4] = lds[offset_lds + (thread * 2 + 1) * lstride]; /* stockham.py:889 */
    R[5] = lds[offset_lds + (thread * 2 + 9) * lstride]; /* stockham.py:889 */
    R[6] = lds[offset_lds + (thread * 2 + 17) * lstride]; /* stockham.py:889 */
    R[7] = lds[offset_lds + (thread * 2 + 25) * lstride]; /* stockham.py:889 */
    W    = {twiddles[7 + 3 * ((2 * thread + 0) % 8)].x,
         -twiddles[7 + 3 * ((2 * thread + 0) % 8)].y}; /* generator.py:1065 */
    t.x  = W.x * R[1].x - W.y * R[1].y; /* stockham.py:899 */
    t.y  = W.y * R[1].x + W.x * R[1].y; /* stockham.py:900 */
    R[1] = t; /* stockham.py:901 */
    W    = {twiddles[8 + 3 * ((2 * thread + 0) % 8)].x,
         -twiddles[8 + 3 * ((2 * thread + 0) % 8)].y}; /* generator.py:1065 */
    t.x  = W.x * R[2].x - W.y * R[2].y; /* stockham.py:899 */
    t.y  = W.y * R[2].x + W.x * R[2].y; /* stockham.py:900 */
    R[2] = t; /* stockham.py:901 */
    W    = {twiddles[9 + 3 * ((2 * thread + 0) % 8)].x,
         -twiddles[9 + 3 * ((2 * thread + 0) % 8)].y}; /* generator.py:1065 */
    t.x  = W.x * R[3].x - W.y * R[3].y; /* stockham.py:899 */
    t.y  = W.y * R[3].x + W.x * R[3].y; /* stockham.py:900 */
    R[3] = t; /* stockham.py:901 */
    W    = {twiddles[7 + 3 * ((2 * thread + 1) % 8)].x,
         -twiddles[7 + 3 * ((2 * thread + 1) % 8)].y}; /* generator.py:1065 */
    t.x  = W.x * R[5].x - W.y * R[5].y; /* stockham.py:899 */
    t.y  = W.y * R[5].x + W.x * R[5].y; /* stockham.py:900 */
    R[5] = t; /* stockham.py:901 */
    W    = {twiddles[8 + 3 * ((2 * thread + 1) % 8)].x,
         -twiddles[8 + 3 * ((2 * thread + 1) % 8)].y}; /* generator.py:1065 */
    t.x  = W.x * R[6].x - W.y * R[6].y; /* stockham.py:899 */
    t.y  = W.y * R[6].x + W.x * R[6].y; /* stockham.py:900 */
    R[6] = t; /* stockham.py:901 */
    W    = {twiddles[9 + 3 * ((2 * thread + 1) % 8)].x,
         -twiddles[9 + 3 * ((2 * thread + 1) % 8)].y}; /* generator.py:1065 */
    t.x  = W.x * R[7].x - W.y * R[7].y; /* stockham.py:899 */
    t.y  = W.y * R[7].x + W.x * R[7].y; /* stockham.py:900 */
    R[7] = t; /* stockham.py:901 */

    InvRad4B1(&R[0], &R[1], &R[2], &R[3]); /* stockham.py:566 */

    InvRad4B1(&R[4], &R[5], &R[6], &R[7]); /* stockham.py:566 */

    __syncthreads();
    if(write)
    {
        lds[offset_lds + (((2 * thread + 0) / 8) * 32 + (2 * thread + 0) % 8 + 0) * lstride]
            = R[0]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 0) / 8) * 32 + (2 * thread + 0) % 8 + 8) * lstride]
            = R[1]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 0) / 8) * 32 + (2 * thread + 0) % 8 + 16) * lstride]
            = R[2]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 0) / 8) * 32 + (2 * thread + 0) % 8 + 24) * lstride]
            = R[3]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 1) / 8) * 32 + (2 * thread + 1) % 8 + 0) * lstride]
            = R[4]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 1) / 8) * 32 + (2 * thread + 1) % 8 + 8) * lstride]
            = R[5]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 1) / 8) * 32 + (2 * thread + 1) % 8 + 16) * lstride]
            = R[6]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 1) / 8) * 32 + (2 * thread + 1) % 8 + 24) * lstride]
            = R[7]; /* stockham.py:913 */
    }
}
/* stockham.py:1076 */
template <typename scalar_type, StrideBin sb, EmbeddedType ebtype, CallbackType cbtype>
__global__
    __launch_bounds__(128) void ip_inverse_length32x32(const scalar_type* __restrict__ twiddles,
                                                       const size_t dim,
                                                       const size_t* __restrict__ lengths,
                                                       const size_t* __restrict__ stride,
                                                       const size_t       nbatch,
                                                       const unsigned int lds_padding,
                                                       void* __restrict__ load_cb_fn,
                                                       void* __restrict__ load_cb_data,
                                                       uint32_t load_cb_lds_bytes,
                                                       void* __restrict__ store_cb_fn,
                                                       void* __restrict__ store_cb_data,
                                                       scalar_type* __restrict__ buf)
{

    //
    // this kernel:
    //   uses 128 threads per 2d transform
    //   does 1 2d transforms per thread block
    // therefore it should be called with 128 threads per thread block
    //
    extern __shared__ unsigned char __align__(sizeof(scalar_type)) lds_uchar[];
    scalar_type* __restrict__ lds = reinterpret_cast<scalar_type*>(lds_uchar);
    size_t       thread;
    size_t       transform;
    size_t       offset = 0;
    unsigned int offset_lds;
    size_t       stride_lds;
    bool         write;
    size_t       stride0;
    size_t       batch0;
    size_t       batch1;
    size_t       remaining;
    size_t       plength = 1;
    int          d;
    size_t       index_along_d;
    auto         load_cb  = get_load_cb<scalar_type, cbtype>(load_cb_fn);
    auto         store_cb = get_store_cb<scalar_type, cbtype>(store_cb_fn);

    //
    // length: 32
    //

    // transform is: length 32 transform number
    // there are 32 * 1 = 32 of them per block
    transform = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:984 */
    remaining = transform; /* stockham.py:985 */
    for(d = 1; d < dim; ++d)
    {
        plength       = plength * lengths[d]; /* stockham.py:988 */
        index_along_d = remaining % lengths[d]; /* stockham.py:989 */
        remaining     = remaining / lengths[d]; /* stockham.py:990 */
        offset        = offset + index_along_d * stride[d]; /* stockham.py:991 */
    }
    batch0 = transform / plength; /* stockham.py:992 */
    offset = offset + batch0 * stride[dim]; /* stockham.py:993 */

    // load following length 32
    write      = batch0 < nbatch; /* stockham.py:999 */
    thread     = threadIdx.x % 4; /* stockham.py:1000 */
    stride0    = stride[0]; /* stockham.py:1001 */
    offset_lds = 32 * (transform % 32); /* stockham.py:1002 */
    if(write)
    {
        lds[offset_lds + thread + 0]
            = load_cb(buf, offset + (thread + 0) * stride0, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 4]
            = load_cb(buf, offset + (thread + 4) * stride0, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 8]
            = load_cb(buf, offset + (thread + 8) * stride0, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 12]
            = load_cb(buf, offset + (thread + 12) * stride0, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 16]
            = load_cb(buf, offset + (thread + 16) * stride0, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 20]
            = load_cb(buf, offset + (thread + 20) * stride0, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 24]
            = load_cb(buf, offset + (thread + 24) * stride0, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 28]
            = load_cb(buf, offset + (thread + 28) * stride0, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
    }
    stride_lds = 1; /* stockham.py:1011 */
    ip_inverse_length32_SBRR_device<scalar_type, SB_UNIT>(
        lds, twiddles, stride_lds, offset_lds, write); /* generator.py:791 */

    //
    // length: 32
    //

    // transform is: length 32 transform number
    // there are 32 * 1 = 32 of them per block
    transform = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:1026 */
    plength   = lengths[0]; /* stockham.py:1027 */
    for(d = 2; d < dim; ++d)
    {
        plength = plength * lengths[d]; /* stockham.py:1030 */
    }
    batch1     = transform / plength; /* stockham.py:1031 */
    write      = batch1 < nbatch; /* stockham.py:1032 */
    thread     = threadIdx.x % 4; /* stockham.py:1033 */
    offset_lds = 1024 * ((transform % 32) / 32) + transform % 32; /* stockham.py:1034 */
    stride_lds = 32; /* stockham.py:1041 */
    ip_inverse_length32_SBRR_device<scalar_type, SB_NONUNIT>(
        lds, twiddles, stride_lds, offset_lds, write); /* generator.py:791 */

    // store following length 32
    __syncthreads();
    transform  = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:1049 */
    write      = batch0 < nbatch; /* stockham.py:1054 */
    thread     = threadIdx.x % 4; /* stockham.py:1055 */
    offset_lds = 32 * (transform % 32); /* stockham.py:1056 */
    if(write)
    {
        store_cb(buf,
                 offset + (thread + 0) * stride0,
                 lds[offset_lds + thread + 0],
                 store_cb_data,
                 nullptr);
        store_cb(buf,
                 offset + (thread + 4) * stride0,
                 lds[offset_lds + thread + 4],
                 store_cb_data,
                 nullptr);
        store_cb(buf,
                 offset + (thread + 8) * stride0,
                 lds[offset_lds + thread + 8],
                 store_cb_data,
                 nullptr);
        store_cb(buf,
                 offset + (thread + 12) * stride0,
                 lds[offset_lds + thread + 12],
                 store_cb_data,
                 nullptr);
        store_cb(buf,
                 offset + (thread + 16) * stride0,
                 lds[offset_lds + thread + 16],
                 store_cb_data,
                 nullptr);
        store_cb(buf,
                 offset + (thread + 20) * stride0,
                 lds[offset_lds + thread + 20],
                 store_cb_data,
                 nullptr);
        store_cb(buf,
                 offset + (thread + 24) * stride0,
                 lds[offset_lds + thread + 24],
                 store_cb_data,
                 nullptr);
        store_cb(buf,
                 offset + (thread + 28) * stride0,
                 lds[offset_lds + thread + 28],
                 store_cb_data,
                 nullptr);
    }
}
/* stockham.py:1076 */
template <typename scalar_type, StrideBin sb, EmbeddedType ebtype, CallbackType cbtype>
__global__
    __launch_bounds__(128) void ip_inverse_length32x32(const scalar_type* __restrict__ twiddles,
                                                       const size_t dim,
                                                       const size_t* __restrict__ lengths,
                                                       const size_t* __restrict__ stride,
                                                       const size_t       nbatch,
                                                       const unsigned int lds_padding,
                                                       void* __restrict__ load_cb_fn,
                                                       void* __restrict__ load_cb_data,
                                                       uint32_t load_cb_lds_bytes,
                                                       void* __restrict__ store_cb_fn,
                                                       void* __restrict__ store_cb_data,
                                                       real_type_t<scalar_type>* __restrict__ bufre,
                                                       real_type_t<scalar_type>* __restrict__ bufim)
{

    //
    // this kernel:
    //   uses 128 threads per 2d transform
    //   does 1 2d transforms per thread block
    // therefore it should be called with 128 threads per thread block
    //
    extern __shared__ unsigned char __align__(sizeof(scalar_type)) lds_uchar[];
    scalar_type* __restrict__ lds = reinterpret_cast<scalar_type*>(lds_uchar);
    size_t       thread;
    size_t       transform;
    size_t       offset = 0;
    unsigned int offset_lds;
    size_t       stride_lds;
    bool         write;
    size_t       stride0;
    size_t       batch0;
    size_t       batch1;
    size_t       remaining;
    size_t       plength = 1;
    int          d;
    size_t       index_along_d;
    auto         load_cb  = get_load_cb<scalar_type, cbtype>(load_cb_fn);
    auto         store_cb = get_store_cb<scalar_type, cbtype>(store_cb_fn);

    //
    // length: 32
    //

    // transform is: length 32 transform number
    // there are 32 * 1 = 32 of them per block
    transform = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:984 */
    remaining = transform; /* stockham.py:985 */
    for(d = 1; d < dim; ++d)
    {
        plength       = plength * lengths[d]; /* stockham.py:988 */
        index_along_d = remaining % lengths[d]; /* stockham.py:989 */
        remaining     = remaining / lengths[d]; /* stockham.py:990 */
        offset        = offset + index_along_d * stride[d]; /* stockham.py:991 */
    }
    batch0 = transform / plength; /* stockham.py:992 */
    offset = offset + batch0 * stride[dim]; /* stockham.py:993 */

    // load following length 32
    write      = batch0 < nbatch; /* stockham.py:999 */
    thread     = threadIdx.x % 4; /* stockham.py:1000 */
    stride0    = stride[0]; /* stockham.py:1001 */
    offset_lds = 32 * (transform % 32); /* stockham.py:1002 */
    if(write)
    {
        lds[offset_lds + thread + 0]
            = {bufre[offset + (thread + 0) * stride0],
               bufim[offset + (thread + 0) * stride0]}; /* generator.py:872 */
        lds[offset_lds + thread + 4]
            = {bufre[offset + (thread + 4) * stride0],
               bufim[offset + (thread + 4) * stride0]}; /* generator.py:872 */
        lds[offset_lds + thread + 8]
            = {bufre[offset + (thread + 8) * stride0],
               bufim[offset + (thread + 8) * stride0]}; /* generator.py:872 */
        lds[offset_lds + thread + 12]
            = {bufre[offset + (thread + 12) * stride0],
               bufim[offset + (thread + 12) * stride0]}; /* generator.py:872 */
        lds[offset_lds + thread + 16]
            = {bufre[offset + (thread + 16) * stride0],
               bufim[offset + (thread + 16) * stride0]}; /* generator.py:872 */
        lds[offset_lds + thread + 20]
            = {bufre[offset + (thread + 20) * stride0],
               bufim[offset + (thread + 20) * stride0]}; /* generator.py:872 */
        lds[offset_lds + thread + 24]
            = {bufre[offset + (thread + 24) * stride0],
               bufim[offset + (thread + 24) * stride0]}; /* generator.py:872 */
        lds[offset_lds + thread + 28]
            = {bufre[offset + (thread + 28) * stride0],
               bufim[offset + (thread + 28) * stride0]}; /* generator.py:872 */
    }
    stride_lds = 1; /* stockham.py:1011 */
    ip_inverse_length32_SBRR_device<scalar_type, SB_UNIT>(
        lds, twiddles, stride_lds, offset_lds, write); /* generator.py:791 */

    //
    // length: 32
    //

    // transform is: length 32 transform number
    // there are 32 * 1 = 32 of them per block
    transform = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:1026 */
    plength   = lengths[0]; /* stockham.py:1027 */
    for(d = 2; d < dim; ++d)
    {
        plength = plength * lengths[d]; /* stockham.py:1030 */
    }
    batch1     = transform / plength; /* stockham.py:1031 */
    write      = batch1 < nbatch; /* stockham.py:1032 */
    thread     = threadIdx.x % 4; /* stockham.py:1033 */
    offset_lds = 1024 * ((transform % 32) / 32) + transform % 32; /* stockham.py:1034 */
    stride_lds = 32; /* stockham.py:1041 */
    ip_inverse_length32_SBRR_device<scalar_type, SB_NONUNIT>(
        lds, twiddles, stride_lds, offset_lds, write); /* generator.py:791 */

    // store following length 32
    __syncthreads();
    transform  = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:1049 */
    write      = batch0 < nbatch; /* stockham.py:1054 */
    thread     = threadIdx.x % 4; /* stockham.py:1055 */
    offset_lds = 32 * (transform % 32); /* stockham.py:1056 */
    if(write)
    {
        bufre[offset + (thread + 0) * stride0]
            = lds[offset_lds + thread + 0].x; /* generator.py:906 */
        bufim[offset + (thread + 0) * stride0]
            = lds[offset_lds + thread + 0].y; /* generator.py:908 */
        bufre[offset + (thread + 4) * stride0]
            = lds[offset_lds + thread + 4].x; /* generator.py:906 */
        bufim[offset + (thread + 4) * stride0]
            = lds[offset_lds + thread + 4].y; /* generator.py:908 */
        bufre[offset + (thread + 8) * stride0]
            = lds[offset_lds + thread + 8].x; /* generator.py:906 */
        bufim[offset + (thread + 8) * stride0]
            = lds[offset_lds + thread + 8].y; /* generator.py:908 */
        bufre[offset + (thread + 12) * stride0]
            = lds[offset_lds + thread + 12].x; /* generator.py:906 */
        bufim[offset + (thread + 12) * stride0]
            = lds[offset_lds + thread + 12].y; /* generator.py:908 */
        bufre[offset + (thread + 16) * stride0]
            = lds[offset_lds + thread + 16].x; /* generator.py:906 */
        bufim[offset + (thread + 16) * stride0]
            = lds[offset_lds + thread + 16].y; /* generator.py:908 */
        bufre[offset + (thread + 20) * stride0]
            = lds[offset_lds + thread + 20].x; /* generator.py:906 */
        bufim[offset + (thread + 20) * stride0]
            = lds[offset_lds + thread + 20].y; /* generator.py:908 */
        bufre[offset + (thread + 24) * stride0]
            = lds[offset_lds + thread + 24].x; /* generator.py:906 */
        bufim[offset + (thread + 24) * stride0]
            = lds[offset_lds + thread + 24].y; /* generator.py:908 */
        bufre[offset + (thread + 28) * stride0]
            = lds[offset_lds + thread + 28].x; /* generator.py:906 */
        bufim[offset + (thread + 28) * stride0]
            = lds[offset_lds + thread + 28].y; /* generator.py:908 */
    }
}
/* stockham.py:926 */
template <typename scalar_type, StrideBin sb>
__device__ void op_inverse_length32_SBRR_device(scalar_type* __restrict__ lds,
                                                const scalar_type* __restrict__ twiddles,
                                                size_t       stride_lds,
                                                unsigned int offset_lds,
                                                bool         write)
{
    size_t       thread;
    scalar_type  R[8];
    scalar_type  W;
    scalar_type  t;
    const size_t lstride = (sb == SB_UNIT) ? (1) : (stride_lds);

    thread = threadIdx.x % 4; /* stockham.py:873 */
    __syncthreads();

    // pass 0
    R[0] = lds[offset_lds + (thread * 1 + 0) * lstride]; /* stockham.py:889 */
    R[1] = lds[offset_lds + (thread * 1 + 4) * lstride]; /* stockham.py:889 */
    R[2] = lds[offset_lds + (thread * 1 + 8) * lstride]; /* stockham.py:889 */
    R[3] = lds[offset_lds + (thread * 1 + 12) * lstride]; /* stockham.py:889 */
    R[4] = lds[offset_lds + (thread * 1 + 16) * lstride]; /* stockham.py:889 */
    R[5] = lds[offset_lds + (thread * 1 + 20) * lstride]; /* stockham.py:889 */
    R[6] = lds[offset_lds + (thread * 1 + 24) * lstride]; /* stockham.py:889 */
    R[7] = lds[offset_lds + (thread * 1 + 28) * lstride]; /* stockham.py:889 */
    InvRad8B1(&R[0], &R[1], &R[2], &R[3], &R[4], &R[5], &R[6], &R[7]); /* stockham.py:566 */

    __syncthreads();
    if(write)
    {
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 0) * lstride]
            = R[0]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 1) * lstride]
            = R[1]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 2) * lstride]
            = R[2]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 3) * lstride]
            = R[3]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 4) * lstride]
            = R[4]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 5) * lstride]
            = R[5]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 6) * lstride]
            = R[6]; /* stockham.py:913 */
        lds[offset_lds + (((1 * thread + 0) / 1) * 8 + (1 * thread + 0) % 1 + 7) * lstride]
            = R[7]; /* stockham.py:913 */
    }

    // pass 1
    __syncthreads();

    R[0] = lds[offset_lds + (thread * 2 + 0) * lstride]; /* stockham.py:889 */
    R[1] = lds[offset_lds + (thread * 2 + 8) * lstride]; /* stockham.py:889 */
    R[2] = lds[offset_lds + (thread * 2 + 16) * lstride]; /* stockham.py:889 */
    R[3] = lds[offset_lds + (thread * 2 + 24) * lstride]; /* stockham.py:889 */
    R[4] = lds[offset_lds + (thread * 2 + 1) * lstride]; /* stockham.py:889 */
    R[5] = lds[offset_lds + (thread * 2 + 9) * lstride]; /* stockham.py:889 */
    R[6] = lds[offset_lds + (thread * 2 + 17) * lstride]; /* stockham.py:889 */
    R[7] = lds[offset_lds + (thread * 2 + 25) * lstride]; /* stockham.py:889 */
    W    = {twiddles[7 + 3 * ((2 * thread + 0) % 8)].x,
         -twiddles[7 + 3 * ((2 * thread + 0) % 8)].y}; /* generator.py:1065 */
    t.x  = W.x * R[1].x - W.y * R[1].y; /* stockham.py:899 */
    t.y  = W.y * R[1].x + W.x * R[1].y; /* stockham.py:900 */
    R[1] = t; /* stockham.py:901 */
    W    = {twiddles[8 + 3 * ((2 * thread + 0) % 8)].x,
         -twiddles[8 + 3 * ((2 * thread + 0) % 8)].y}; /* generator.py:1065 */
    t.x  = W.x * R[2].x - W.y * R[2].y; /* stockham.py:899 */
    t.y  = W.y * R[2].x + W.x * R[2].y; /* stockham.py:900 */
    R[2] = t; /* stockham.py:901 */
    W    = {twiddles[9 + 3 * ((2 * thread + 0) % 8)].x,
         -twiddles[9 + 3 * ((2 * thread + 0) % 8)].y}; /* generator.py:1065 */
    t.x  = W.x * R[3].x - W.y * R[3].y; /* stockham.py:899 */
    t.y  = W.y * R[3].x + W.x * R[3].y; /* stockham.py:900 */
    R[3] = t; /* stockham.py:901 */
    W    = {twiddles[7 + 3 * ((2 * thread + 1) % 8)].x,
         -twiddles[7 + 3 * ((2 * thread + 1) % 8)].y}; /* generator.py:1065 */
    t.x  = W.x * R[5].x - W.y * R[5].y; /* stockham.py:899 */
    t.y  = W.y * R[5].x + W.x * R[5].y; /* stockham.py:900 */
    R[5] = t; /* stockham.py:901 */
    W    = {twiddles[8 + 3 * ((2 * thread + 1) % 8)].x,
         -twiddles[8 + 3 * ((2 * thread + 1) % 8)].y}; /* generator.py:1065 */
    t.x  = W.x * R[6].x - W.y * R[6].y; /* stockham.py:899 */
    t.y  = W.y * R[6].x + W.x * R[6].y; /* stockham.py:900 */
    R[6] = t; /* stockham.py:901 */
    W    = {twiddles[9 + 3 * ((2 * thread + 1) % 8)].x,
         -twiddles[9 + 3 * ((2 * thread + 1) % 8)].y}; /* generator.py:1065 */
    t.x  = W.x * R[7].x - W.y * R[7].y; /* stockham.py:899 */
    t.y  = W.y * R[7].x + W.x * R[7].y; /* stockham.py:900 */
    R[7] = t; /* stockham.py:901 */

    InvRad4B1(&R[0], &R[1], &R[2], &R[3]); /* stockham.py:566 */

    InvRad4B1(&R[4], &R[5], &R[6], &R[7]); /* stockham.py:566 */

    __syncthreads();
    if(write)
    {
        lds[offset_lds + (((2 * thread + 0) / 8) * 32 + (2 * thread + 0) % 8 + 0) * lstride]
            = R[0]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 0) / 8) * 32 + (2 * thread + 0) % 8 + 8) * lstride]
            = R[1]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 0) / 8) * 32 + (2 * thread + 0) % 8 + 16) * lstride]
            = R[2]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 0) / 8) * 32 + (2 * thread + 0) % 8 + 24) * lstride]
            = R[3]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 1) / 8) * 32 + (2 * thread + 1) % 8 + 0) * lstride]
            = R[4]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 1) / 8) * 32 + (2 * thread + 1) % 8 + 8) * lstride]
            = R[5]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 1) / 8) * 32 + (2 * thread + 1) % 8 + 16) * lstride]
            = R[6]; /* stockham.py:913 */
        lds[offset_lds + (((2 * thread + 1) / 8) * 32 + (2 * thread + 1) % 8 + 24) * lstride]
            = R[7]; /* stockham.py:913 */
    }
}
/* stockham.py:1076 */
template <typename scalar_type, StrideBin sb, EmbeddedType ebtype, CallbackType cbtype>
__global__
    __launch_bounds__(128) void op_inverse_length32x32(const scalar_type* __restrict__ twiddles,
                                                       const size_t dim,
                                                       const size_t* __restrict__ lengths,
                                                       const size_t* __restrict__ stride_in,
                                                       const size_t* __restrict__ stride_out,
                                                       const size_t       nbatch,
                                                       const unsigned int lds_padding,
                                                       void* __restrict__ load_cb_fn,
                                                       void* __restrict__ load_cb_data,
                                                       uint32_t load_cb_lds_bytes,
                                                       void* __restrict__ store_cb_fn,
                                                       void* __restrict__ store_cb_data,
                                                       scalar_type* __restrict__ buf_in,
                                                       scalar_type* __restrict__ buf_out)
{

    //
    // this kernel:
    //   uses 128 threads per 2d transform
    //   does 1 2d transforms per thread block
    // therefore it should be called with 128 threads per thread block
    //
    extern __shared__ unsigned char __align__(sizeof(scalar_type)) lds_uchar[];
    scalar_type* __restrict__ lds = reinterpret_cast<scalar_type*>(lds_uchar);
    size_t       thread;
    size_t       transform;
    size_t       offset_in  = 0;
    size_t       offset_out = 0;
    unsigned int offset_lds;
    size_t       stride_lds;
    bool         write;
    size_t       stride0_in;
    size_t       stride0_out;
    size_t       batch0;
    size_t       batch1;
    size_t       remaining;
    size_t       plength = 1;
    int          d;
    size_t       index_along_d;
    auto         load_cb  = get_load_cb<scalar_type, cbtype>(load_cb_fn);
    auto         store_cb = get_store_cb<scalar_type, cbtype>(store_cb_fn);

    //
    // length: 32
    //

    // transform is: length 32 transform number
    // there are 32 * 1 = 32 of them per block
    transform = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:984 */
    remaining = transform; /* stockham.py:985 */
    for(d = 1; d < dim; ++d)
    {
        plength       = plength * lengths[d]; /* stockham.py:988 */
        index_along_d = remaining % lengths[d]; /* stockham.py:989 */
        remaining     = remaining / lengths[d]; /* stockham.py:990 */
        offset_in     = offset_in + index_along_d * stride_in[d]; /* generator.py:992 */
        offset_out    = offset_out + index_along_d * stride_out[d]; /* generator.py:993 */
    }
    batch0     = transform / plength; /* stockham.py:992 */
    offset_in  = offset_in + batch0 * stride_in[dim]; /* generator.py:992 */
    offset_out = offset_out + batch0 * stride_out[dim]; /* generator.py:993 */

    // load following length 32
    write       = batch0 < nbatch; /* stockham.py:999 */
    thread      = threadIdx.x % 4; /* stockham.py:1000 */
    stride0_in  = stride_in[0]; /* generator.py:992 */
    stride0_out = stride_out[0]; /* generator.py:993 */
    offset_lds  = 32 * (transform % 32); /* stockham.py:1002 */
    if(write)
    {
        lds[offset_lds + thread + 0]
            = load_cb(buf_in, offset_in + (thread + 0) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 4]
            = load_cb(buf_in, offset_in + (thread + 4) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 8]
            = load_cb(buf_in, offset_in + (thread + 8) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 12]
            = load_cb(buf_in, offset_in + (thread + 12) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 16]
            = load_cb(buf_in, offset_in + (thread + 16) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 20]
            = load_cb(buf_in, offset_in + (thread + 20) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 24]
            = load_cb(buf_in, offset_in + (thread + 24) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 28]
            = load_cb(buf_in, offset_in + (thread + 28) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
    }
    stride_lds = 1; /* stockham.py:1011 */
    op_inverse_length32_SBRR_device<scalar_type, SB_UNIT>(
        lds, twiddles, stride_lds, offset_lds, write); /* generator.py:791 */

    //
    // length: 32
    //

    // transform is: length 32 transform number
    // there are 32 * 1 = 32 of them per block
    transform = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:1026 */
    plength   = lengths[0]; /* stockham.py:1027 */
    for(d = 2; d < dim; ++d)
    {
        plength = plength * lengths[d]; /* stockham.py:1030 */
    }
    batch1     = transform / plength; /* stockham.py:1031 */
    write      = batch1 < nbatch; /* stockham.py:1032 */
    thread     = threadIdx.x % 4; /* stockham.py:1033 */
    offset_lds = 1024 * ((transform % 32) / 32) + transform % 32; /* stockham.py:1034 */
    stride_lds = 32; /* stockham.py:1041 */
    op_inverse_length32_SBRR_device<scalar_type, SB_NONUNIT>(
        lds, twiddles, stride_lds, offset_lds, write); /* generator.py:791 */

    // store following length 32
    __syncthreads();
    transform  = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:1049 */
    write      = batch0 < nbatch; /* stockham.py:1054 */
    thread     = threadIdx.x % 4; /* stockham.py:1055 */
    offset_lds = 32 * (transform % 32); /* stockham.py:1056 */
    if(write)
    {
        store_cb(buf_out,
                 offset_out + (thread + 0) * stride0_out,
                 lds[offset_lds + thread + 0],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 4) * stride0_out,
                 lds[offset_lds + thread + 4],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 8) * stride0_out,
                 lds[offset_lds + thread + 8],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 12) * stride0_out,
                 lds[offset_lds + thread + 12],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 16) * stride0_out,
                 lds[offset_lds + thread + 16],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 20) * stride0_out,
                 lds[offset_lds + thread + 20],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 24) * stride0_out,
                 lds[offset_lds + thread + 24],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 28) * stride0_out,
                 lds[offset_lds + thread + 28],
                 store_cb_data,
                 nullptr);
    }
}
/* stockham.py:1076 */
template <typename scalar_type, StrideBin sb, EmbeddedType ebtype, CallbackType cbtype>
__global__ __launch_bounds__(128) void op_inverse_length32x32(
    const scalar_type* __restrict__ twiddles,
    const size_t dim,
    const size_t* __restrict__ lengths,
    const size_t* __restrict__ stride_in,
    const size_t* __restrict__ stride_out,
    const size_t       nbatch,
    const unsigned int lds_padding,
    void* __restrict__ load_cb_fn,
    void* __restrict__ load_cb_data,
    uint32_t load_cb_lds_bytes,
    void* __restrict__ store_cb_fn,
    void* __restrict__ store_cb_data,
    scalar_type* __restrict__ buf_in,
    real_type_t<scalar_type>* __restrict__ buf_outre,
    real_type_t<scalar_type>* __restrict__ buf_outim)
{

    //
    // this kernel:
    //   uses 128 threads per 2d transform
    //   does 1 2d transforms per thread block
    // therefore it should be called with 128 threads per thread block
    //
    extern __shared__ unsigned char __align__(sizeof(scalar_type)) lds_uchar[];
    scalar_type* __restrict__ lds = reinterpret_cast<scalar_type*>(lds_uchar);
    size_t       thread;
    size_t       transform;
    size_t       offset_in  = 0;
    size_t       offset_out = 0;
    unsigned int offset_lds;
    size_t       stride_lds;
    bool         write;
    size_t       stride0_in;
    size_t       stride0_out;
    size_t       batch0;
    size_t       batch1;
    size_t       remaining;
    size_t       plength = 1;
    int          d;
    size_t       index_along_d;
    auto         load_cb  = get_load_cb<scalar_type, cbtype>(load_cb_fn);
    auto         store_cb = get_store_cb<scalar_type, cbtype>(store_cb_fn);

    //
    // length: 32
    //

    // transform is: length 32 transform number
    // there are 32 * 1 = 32 of them per block
    transform = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:984 */
    remaining = transform; /* stockham.py:985 */
    for(d = 1; d < dim; ++d)
    {
        plength       = plength * lengths[d]; /* stockham.py:988 */
        index_along_d = remaining % lengths[d]; /* stockham.py:989 */
        remaining     = remaining / lengths[d]; /* stockham.py:990 */
        offset_in     = offset_in + index_along_d * stride_in[d]; /* generator.py:992 */
        offset_out    = offset_out + index_along_d * stride_out[d]; /* generator.py:993 */
    }
    batch0     = transform / plength; /* stockham.py:992 */
    offset_in  = offset_in + batch0 * stride_in[dim]; /* generator.py:992 */
    offset_out = offset_out + batch0 * stride_out[dim]; /* generator.py:993 */

    // load following length 32
    write       = batch0 < nbatch; /* stockham.py:999 */
    thread      = threadIdx.x % 4; /* stockham.py:1000 */
    stride0_in  = stride_in[0]; /* generator.py:992 */
    stride0_out = stride_out[0]; /* generator.py:993 */
    offset_lds  = 32 * (transform % 32); /* stockham.py:1002 */
    if(write)
    {
        lds[offset_lds + thread + 0]
            = load_cb(buf_in, offset_in + (thread + 0) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 4]
            = load_cb(buf_in, offset_in + (thread + 4) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 8]
            = load_cb(buf_in, offset_in + (thread + 8) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 12]
            = load_cb(buf_in, offset_in + (thread + 12) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 16]
            = load_cb(buf_in, offset_in + (thread + 16) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 20]
            = load_cb(buf_in, offset_in + (thread + 20) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 24]
            = load_cb(buf_in, offset_in + (thread + 24) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
        lds[offset_lds + thread + 28]
            = load_cb(buf_in, offset_in + (thread + 28) * stride0_in, load_cb_data, nullptr);
        ; /* stockham.py:1006 */
    }
    stride_lds = 1; /* stockham.py:1011 */
    op_inverse_length32_SBRR_device<scalar_type, SB_UNIT>(
        lds, twiddles, stride_lds, offset_lds, write); /* generator.py:791 */

    //
    // length: 32
    //

    // transform is: length 32 transform number
    // there are 32 * 1 = 32 of them per block
    transform = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:1026 */
    plength   = lengths[0]; /* stockham.py:1027 */
    for(d = 2; d < dim; ++d)
    {
        plength = plength * lengths[d]; /* stockham.py:1030 */
    }
    batch1     = transform / plength; /* stockham.py:1031 */
    write      = batch1 < nbatch; /* stockham.py:1032 */
    thread     = threadIdx.x % 4; /* stockham.py:1033 */
    offset_lds = 1024 * ((transform % 32) / 32) + transform % 32; /* stockham.py:1034 */
    stride_lds = 32; /* stockham.py:1041 */
    op_inverse_length32_SBRR_device<scalar_type, SB_NONUNIT>(
        lds, twiddles, stride_lds, offset_lds, write); /* generator.py:791 */

    // store following length 32
    __syncthreads();
    transform  = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:1049 */
    write      = batch0 < nbatch; /* stockham.py:1054 */
    thread     = threadIdx.x % 4; /* stockham.py:1055 */
    offset_lds = 32 * (transform % 32); /* stockham.py:1056 */
    if(write)
    {
        buf_outre[offset_out + (thread + 0) * stride0_out]
            = lds[offset_lds + thread + 0].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 0) * stride0_out]
            = lds[offset_lds + thread + 0].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 4) * stride0_out]
            = lds[offset_lds + thread + 4].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 4) * stride0_out]
            = lds[offset_lds + thread + 4].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 8) * stride0_out]
            = lds[offset_lds + thread + 8].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 8) * stride0_out]
            = lds[offset_lds + thread + 8].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 12) * stride0_out]
            = lds[offset_lds + thread + 12].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 12) * stride0_out]
            = lds[offset_lds + thread + 12].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 16) * stride0_out]
            = lds[offset_lds + thread + 16].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 16) * stride0_out]
            = lds[offset_lds + thread + 16].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 20) * stride0_out]
            = lds[offset_lds + thread + 20].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 20) * stride0_out]
            = lds[offset_lds + thread + 20].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 24) * stride0_out]
            = lds[offset_lds + thread + 24].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 24) * stride0_out]
            = lds[offset_lds + thread + 24].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 28) * stride0_out]
            = lds[offset_lds + thread + 28].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 28) * stride0_out]
            = lds[offset_lds + thread + 28].y; /* generator.py:908 */
    }
}
/* stockham.py:1076 */
template <typename scalar_type, StrideBin sb, EmbeddedType ebtype, CallbackType cbtype>
__global__ __launch_bounds__(128) void op_inverse_length32x32(
    const scalar_type* __restrict__ twiddles,
    const size_t dim,
    const size_t* __restrict__ lengths,
    const size_t* __restrict__ stride_in,
    const size_t* __restrict__ stride_out,
    const size_t       nbatch,
    const unsigned int lds_padding,
    void* __restrict__ load_cb_fn,
    void* __restrict__ load_cb_data,
    uint32_t load_cb_lds_bytes,
    void* __restrict__ store_cb_fn,
    void* __restrict__ store_cb_data,
    real_type_t<scalar_type>* __restrict__ buf_inre,
    real_type_t<scalar_type>* __restrict__ buf_inim,
    scalar_type* __restrict__ buf_out)
{

    //
    // this kernel:
    //   uses 128 threads per 2d transform
    //   does 1 2d transforms per thread block
    // therefore it should be called with 128 threads per thread block
    //
    extern __shared__ unsigned char __align__(sizeof(scalar_type)) lds_uchar[];
    scalar_type* __restrict__ lds = reinterpret_cast<scalar_type*>(lds_uchar);
    size_t       thread;
    size_t       transform;
    size_t       offset_in  = 0;
    size_t       offset_out = 0;
    unsigned int offset_lds;
    size_t       stride_lds;
    bool         write;
    size_t       stride0_in;
    size_t       stride0_out;
    size_t       batch0;
    size_t       batch1;
    size_t       remaining;
    size_t       plength = 1;
    int          d;
    size_t       index_along_d;
    auto         load_cb  = get_load_cb<scalar_type, cbtype>(load_cb_fn);
    auto         store_cb = get_store_cb<scalar_type, cbtype>(store_cb_fn);

    //
    // length: 32
    //

    // transform is: length 32 transform number
    // there are 32 * 1 = 32 of them per block
    transform = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:984 */
    remaining = transform; /* stockham.py:985 */
    for(d = 1; d < dim; ++d)
    {
        plength       = plength * lengths[d]; /* stockham.py:988 */
        index_along_d = remaining % lengths[d]; /* stockham.py:989 */
        remaining     = remaining / lengths[d]; /* stockham.py:990 */
        offset_in     = offset_in + index_along_d * stride_in[d]; /* generator.py:992 */
        offset_out    = offset_out + index_along_d * stride_out[d]; /* generator.py:993 */
    }
    batch0     = transform / plength; /* stockham.py:992 */
    offset_in  = offset_in + batch0 * stride_in[dim]; /* generator.py:992 */
    offset_out = offset_out + batch0 * stride_out[dim]; /* generator.py:993 */

    // load following length 32
    write       = batch0 < nbatch; /* stockham.py:999 */
    thread      = threadIdx.x % 4; /* stockham.py:1000 */
    stride0_in  = stride_in[0]; /* generator.py:992 */
    stride0_out = stride_out[0]; /* generator.py:993 */
    offset_lds  = 32 * (transform % 32); /* stockham.py:1002 */
    if(write)
    {
        lds[offset_lds + thread + 0]
            = {buf_inre[offset_in + (thread + 0) * stride0_in],
               buf_inim[offset_in + (thread + 0) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 4]
            = {buf_inre[offset_in + (thread + 4) * stride0_in],
               buf_inim[offset_in + (thread + 4) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 8]
            = {buf_inre[offset_in + (thread + 8) * stride0_in],
               buf_inim[offset_in + (thread + 8) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 12]
            = {buf_inre[offset_in + (thread + 12) * stride0_in],
               buf_inim[offset_in + (thread + 12) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 16]
            = {buf_inre[offset_in + (thread + 16) * stride0_in],
               buf_inim[offset_in + (thread + 16) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 20]
            = {buf_inre[offset_in + (thread + 20) * stride0_in],
               buf_inim[offset_in + (thread + 20) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 24]
            = {buf_inre[offset_in + (thread + 24) * stride0_in],
               buf_inim[offset_in + (thread + 24) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 28]
            = {buf_inre[offset_in + (thread + 28) * stride0_in],
               buf_inim[offset_in + (thread + 28) * stride0_in]}; /* generator.py:872 */
    }
    stride_lds = 1; /* stockham.py:1011 */
    op_inverse_length32_SBRR_device<scalar_type, SB_UNIT>(
        lds, twiddles, stride_lds, offset_lds, write); /* generator.py:791 */

    //
    // length: 32
    //

    // transform is: length 32 transform number
    // there are 32 * 1 = 32 of them per block
    transform = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:1026 */
    plength   = lengths[0]; /* stockham.py:1027 */
    for(d = 2; d < dim; ++d)
    {
        plength = plength * lengths[d]; /* stockham.py:1030 */
    }
    batch1     = transform / plength; /* stockham.py:1031 */
    write      = batch1 < nbatch; /* stockham.py:1032 */
    thread     = threadIdx.x % 4; /* stockham.py:1033 */
    offset_lds = 1024 * ((transform % 32) / 32) + transform % 32; /* stockham.py:1034 */
    stride_lds = 32; /* stockham.py:1041 */
    op_inverse_length32_SBRR_device<scalar_type, SB_NONUNIT>(
        lds, twiddles, stride_lds, offset_lds, write); /* generator.py:791 */

    // store following length 32
    __syncthreads();
    transform  = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:1049 */
    write      = batch0 < nbatch; /* stockham.py:1054 */
    thread     = threadIdx.x % 4; /* stockham.py:1055 */
    offset_lds = 32 * (transform % 32); /* stockham.py:1056 */
    if(write)
    {
        store_cb(buf_out,
                 offset_out + (thread + 0) * stride0_out,
                 lds[offset_lds + thread + 0],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 4) * stride0_out,
                 lds[offset_lds + thread + 4],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 8) * stride0_out,
                 lds[offset_lds + thread + 8],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 12) * stride0_out,
                 lds[offset_lds + thread + 12],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 16) * stride0_out,
                 lds[offset_lds + thread + 16],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 20) * stride0_out,
                 lds[offset_lds + thread + 20],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 24) * stride0_out,
                 lds[offset_lds + thread + 24],
                 store_cb_data,
                 nullptr);
        store_cb(buf_out,
                 offset_out + (thread + 28) * stride0_out,
                 lds[offset_lds + thread + 28],
                 store_cb_data,
                 nullptr);
    }
}
/* stockham.py:1076 */
template <typename scalar_type, StrideBin sb, EmbeddedType ebtype, CallbackType cbtype>
__global__ __launch_bounds__(128) void op_inverse_length32x32(
    const scalar_type* __restrict__ twiddles,
    const size_t dim,
    const size_t* __restrict__ lengths,
    const size_t* __restrict__ stride_in,
    const size_t* __restrict__ stride_out,
    const size_t       nbatch,
    const unsigned int lds_padding,
    void* __restrict__ load_cb_fn,
    void* __restrict__ load_cb_data,
    uint32_t load_cb_lds_bytes,
    void* __restrict__ store_cb_fn,
    void* __restrict__ store_cb_data,
    real_type_t<scalar_type>* __restrict__ buf_inre,
    real_type_t<scalar_type>* __restrict__ buf_inim,
    real_type_t<scalar_type>* __restrict__ buf_outre,
    real_type_t<scalar_type>* __restrict__ buf_outim)
{

    //
    // this kernel:
    //   uses 128 threads per 2d transform
    //   does 1 2d transforms per thread block
    // therefore it should be called with 128 threads per thread block
    //
    extern __shared__ unsigned char __align__(sizeof(scalar_type)) lds_uchar[];
    scalar_type* __restrict__ lds = reinterpret_cast<scalar_type*>(lds_uchar);
    size_t       thread;
    size_t       transform;
    size_t       offset_in  = 0;
    size_t       offset_out = 0;
    unsigned int offset_lds;
    size_t       stride_lds;
    bool         write;
    size_t       stride0_in;
    size_t       stride0_out;
    size_t       batch0;
    size_t       batch1;
    size_t       remaining;
    size_t       plength = 1;
    int          d;
    size_t       index_along_d;
    auto         load_cb  = get_load_cb<scalar_type, cbtype>(load_cb_fn);
    auto         store_cb = get_store_cb<scalar_type, cbtype>(store_cb_fn);

    //
    // length: 32
    //

    // transform is: length 32 transform number
    // there are 32 * 1 = 32 of them per block
    transform = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:984 */
    remaining = transform; /* stockham.py:985 */
    for(d = 1; d < dim; ++d)
    {
        plength       = plength * lengths[d]; /* stockham.py:988 */
        index_along_d = remaining % lengths[d]; /* stockham.py:989 */
        remaining     = remaining / lengths[d]; /* stockham.py:990 */
        offset_in     = offset_in + index_along_d * stride_in[d]; /* generator.py:992 */
        offset_out    = offset_out + index_along_d * stride_out[d]; /* generator.py:993 */
    }
    batch0     = transform / plength; /* stockham.py:992 */
    offset_in  = offset_in + batch0 * stride_in[dim]; /* generator.py:992 */
    offset_out = offset_out + batch0 * stride_out[dim]; /* generator.py:993 */

    // load following length 32
    write       = batch0 < nbatch; /* stockham.py:999 */
    thread      = threadIdx.x % 4; /* stockham.py:1000 */
    stride0_in  = stride_in[0]; /* generator.py:992 */
    stride0_out = stride_out[0]; /* generator.py:993 */
    offset_lds  = 32 * (transform % 32); /* stockham.py:1002 */
    if(write)
    {
        lds[offset_lds + thread + 0]
            = {buf_inre[offset_in + (thread + 0) * stride0_in],
               buf_inim[offset_in + (thread + 0) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 4]
            = {buf_inre[offset_in + (thread + 4) * stride0_in],
               buf_inim[offset_in + (thread + 4) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 8]
            = {buf_inre[offset_in + (thread + 8) * stride0_in],
               buf_inim[offset_in + (thread + 8) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 12]
            = {buf_inre[offset_in + (thread + 12) * stride0_in],
               buf_inim[offset_in + (thread + 12) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 16]
            = {buf_inre[offset_in + (thread + 16) * stride0_in],
               buf_inim[offset_in + (thread + 16) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 20]
            = {buf_inre[offset_in + (thread + 20) * stride0_in],
               buf_inim[offset_in + (thread + 20) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 24]
            = {buf_inre[offset_in + (thread + 24) * stride0_in],
               buf_inim[offset_in + (thread + 24) * stride0_in]}; /* generator.py:872 */
        lds[offset_lds + thread + 28]
            = {buf_inre[offset_in + (thread + 28) * stride0_in],
               buf_inim[offset_in + (thread + 28) * stride0_in]}; /* generator.py:872 */
    }
    stride_lds = 1; /* stockham.py:1011 */
    op_inverse_length32_SBRR_device<scalar_type, SB_UNIT>(
        lds, twiddles, stride_lds, offset_lds, write); /* generator.py:791 */

    //
    // length: 32
    //

    // transform is: length 32 transform number
    // there are 32 * 1 = 32 of them per block
    transform = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:1026 */
    plength   = lengths[0]; /* stockham.py:1027 */
    for(d = 2; d < dim; ++d)
    {
        plength = plength * lengths[d]; /* stockham.py:1030 */
    }
    batch1     = transform / plength; /* stockham.py:1031 */
    write      = batch1 < nbatch; /* stockham.py:1032 */
    thread     = threadIdx.x % 4; /* stockham.py:1033 */
    offset_lds = 1024 * ((transform % 32) / 32) + transform % 32; /* stockham.py:1034 */
    stride_lds = 32; /* stockham.py:1041 */
    op_inverse_length32_SBRR_device<scalar_type, SB_NONUNIT>(
        lds, twiddles, stride_lds, offset_lds, write); /* generator.py:791 */

    // store following length 32
    __syncthreads();
    transform  = blockIdx.x * 32 + threadIdx.x / 4; /* stockham.py:1049 */
    write      = batch0 < nbatch; /* stockham.py:1054 */
    thread     = threadIdx.x % 4; /* stockham.py:1055 */
    offset_lds = 32 * (transform % 32); /* stockham.py:1056 */
    if(write)
    {
        buf_outre[offset_out + (thread + 0) * stride0_out]
            = lds[offset_lds + thread + 0].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 0) * stride0_out]
            = lds[offset_lds + thread + 0].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 4) * stride0_out]
            = lds[offset_lds + thread + 4].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 4) * stride0_out]
            = lds[offset_lds + thread + 4].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 8) * stride0_out]
            = lds[offset_lds + thread + 8].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 8) * stride0_out]
            = lds[offset_lds + thread + 8].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 12) * stride0_out]
            = lds[offset_lds + thread + 12].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 12) * stride0_out]
            = lds[offset_lds + thread + 12].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 16) * stride0_out]
            = lds[offset_lds + thread + 16].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 16) * stride0_out]
            = lds[offset_lds + thread + 16].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 20) * stride0_out]
            = lds[offset_lds + thread + 20].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 20) * stride0_out]
            = lds[offset_lds + thread + 20].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 24) * stride0_out]
            = lds[offset_lds + thread + 24].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 24) * stride0_out]
            = lds[offset_lds + thread + 24].y; /* generator.py:908 */
        buf_outre[offset_out + (thread + 28) * stride0_out]
            = lds[offset_lds + thread + 28].x; /* generator.py:906 */
        buf_outim[offset_out + (thread + 28) * stride0_out]
            = lds[offset_lds + thread + 28].y; /* generator.py:908 */
    }
}
POWX_SMALL_GENERATOR(rocfft_internal_dfn_dp_ci_ci_2D_32_32,
                     ip_forward_length32x32,
                     ip_inverse_length32x32,
                     op_forward_length32x32,
                     op_inverse_length32x32,
                     double2);
POWX_SMALL_GENERATOR(rocfft_internal_dfn_sp_ci_ci_2D_32_32,
                     ip_forward_length32x32,
                     ip_inverse_length32x32,
                     op_forward_length32x32,
                     op_inverse_length32x32,
                     float2);